<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Xmipp API Documentation: Blobs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xmipp_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Xmipp API Documentation
   &#160;<span id="projectnumber">v20.07</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Blobs<div class="ingroups"><a class="el" href="group__BasisFunction.html">Basis function</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Blobs:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__Blobs.png" border="0" alt="" usemap="#group____Blobs"/>
<map name="group____Blobs" id="group____Blobs">
<area shape="rect" id="node1" href="group__BasisFunction.html" title="Basis function" alt="" coords="5,5,111,32"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structblobtype.html">blobtype</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaeba6cc6d681f05be51139d9d5c21a305"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Blobs.html#gaeba6cc6d681f05be51139d9d5c21a305">blob_val</a>(r,  blob)&#160;&#160;&#160;<a class="el" href="group__Blobs.html#ga1d25336dea0e85d705d18ebdb27f018a">kaiser_value</a>(r, blob.radius, blob.alpha, blob.order)</td></tr>
<tr class="separator:gaeba6cc6d681f05be51139d9d5c21a305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0af420e41e9958b9c5b562c1df9a6b9e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Blobs.html#ga0af420e41e9958b9c5b562c1df9a6b9e">blob_proj</a>(r,  blob)&#160;&#160;&#160;<a class="el" href="group__Blobs.html#gae3586255797a1a110ba99268a050ccef">kaiser_proj</a>(r, blob.radius, blob.alpha, blob.order)</td></tr>
<tr class="separator:ga0af420e41e9958b9c5b562c1df9a6b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8119af50e3fa095d670c01a680d9f2cc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Blobs.html#ga8119af50e3fa095d670c01a680d9f2cc">blob_Fourier_val</a>(<a class="el" href="numerical__recipes_8cpp.html#a2b83edee7677c7a2b0a4e5ac99baa586">w</a>,  blob)&#160;&#160;&#160;<a class="el" href="group__Blobs.html#gad2a185cd88a0d1a7e22ccbaa01624751">kaiser_Fourier_value</a>(<a class="el" href="numerical__recipes_8cpp.html#a2b83edee7677c7a2b0a4e5ac99baa586">w</a>, blob.radius, blob.alpha, blob.order)</td></tr>
<tr class="separator:ga8119af50e3fa095d670c01a680d9f2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a62015b2158b9644950af306dc8b856"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Blobs.html#ga5a62015b2158b9644950af306dc8b856">blob_mass</a>(blob)&#160;&#160;&#160;<a class="el" href="group__Blobs.html#gad30bf1a00f736d5378040c6d4f4e30a5">basvolume</a>(blob.radius, blob.alpha, blob.order,3)</td></tr>
<tr class="separator:ga5a62015b2158b9644950af306dc8b856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1f8107fe2e79dd5a210df9509ab6055"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Blobs.html#gad1f8107fe2e79dd5a210df9509ab6055">SHOW_CONVERSION</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:gad1f8107fe2e79dd5a210df9509ab6055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1a62943287cc2f243753d3a9d0dcd9d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Blobs.html#gae1a62943287cc2f243753d3a9d0dcd9d">VARTK</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:gae1a62943287cc2f243753d3a9d0dcd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fbce6fd195e1787971b7b93e82cbbd5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Blobs.html#ga3fbce6fd195e1787971b7b93e82cbbd5">VMAXARTK</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga3fbce6fd195e1787971b7b93e82cbbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1d25336dea0e85d705d18ebdb27f018a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Blobs.html#ga1d25336dea0e85d705d18ebdb27f018a">kaiser_value</a> (double r, double <a class="el" href="numerical__recipes_8cpp.html#af2a333b1670df64a88d3a2f22210d155">a</a>, double alpha, int <a class="el" href="numerical__recipes_8cpp.html#a438c75002165fed58970c95d67a268c1">m</a>)</td></tr>
<tr class="separator:ga1d25336dea0e85d705d18ebdb27f018a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3586255797a1a110ba99268a050ccef"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Blobs.html#gae3586255797a1a110ba99268a050ccef">kaiser_proj</a> (double r, double <a class="el" href="numerical__recipes_8cpp.html#af2a333b1670df64a88d3a2f22210d155">a</a>, double alpha, int <a class="el" href="numerical__recipes_8cpp.html#a438c75002165fed58970c95d67a268c1">m</a>)</td></tr>
<tr class="separator:gae3586255797a1a110ba99268a050ccef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2a185cd88a0d1a7e22ccbaa01624751"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Blobs.html#gad2a185cd88a0d1a7e22ccbaa01624751">kaiser_Fourier_value</a> (double <a class="el" href="numerical__recipes_8cpp.html#a2b83edee7677c7a2b0a4e5ac99baa586">w</a>, double <a class="el" href="numerical__recipes_8cpp.html#af2a333b1670df64a88d3a2f22210d155">a</a>, double alpha, int <a class="el" href="numerical__recipes_8cpp.html#a438c75002165fed58970c95d67a268c1">m</a>)</td></tr>
<tr class="separator:gad2a185cd88a0d1a7e22ccbaa01624751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad30bf1a00f736d5378040c6d4f4e30a5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Blobs.html#gad30bf1a00f736d5378040c6d4f4e30a5">basvolume</a> (double <a class="el" href="numerical__recipes_8cpp.html#af2a333b1670df64a88d3a2f22210d155">a</a>, double alpha, int <a class="el" href="numerical__recipes_8cpp.html#a438c75002165fed58970c95d67a268c1">m</a>, int <a class="el" href="numerical__recipes_8cpp.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)</td></tr>
<tr class="separator:gad30bf1a00f736d5378040c6d4f4e30a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ca9464825734b841e8fe3b688d4210b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Blobs.html#ga9ca9464825734b841e8fe3b688d4210b">in_zeroarg</a> (int <a class="el" href="numerical__recipes_8cpp.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)</td></tr>
<tr class="separator:ga9ca9464825734b841e8fe3b688d4210b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5535ae1ec6293ae20ff93667838ab722"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Blobs.html#ga5535ae1ec6293ae20ff93667838ab722">inph_zeroarg</a> (int <a class="el" href="numerical__recipes_8cpp.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>)</td></tr>
<tr class="separator:ga5535ae1ec6293ae20ff93667838ab722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c16f98dae81ec5758de5d1de321e4a8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Blobs.html#ga1c16f98dae81ec5758de5d1de321e4a8">i_nph</a> (int <a class="el" href="numerical__recipes_8cpp.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>, double <a class="el" href="numerical__recipes_8cpp.html#ab81d9253b246f09be9999505d515d517">x</a>)</td></tr>
<tr class="separator:ga1c16f98dae81ec5758de5d1de321e4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1c7e82811e94d7957dc0f8891a57cfa"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Blobs.html#gab1c7e82811e94d7957dc0f8891a57cfa">i_n</a> (int <a class="el" href="numerical__recipes_8cpp.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>, double <a class="el" href="numerical__recipes_8cpp.html#ab81d9253b246f09be9999505d515d517">x</a>)</td></tr>
<tr class="separator:gab1c7e82811e94d7957dc0f8891a57cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87a45c6b1e8619e08888ab103c1fd7f9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Blobs.html#ga87a45c6b1e8619e08888ab103c1fd7f9">blob_freq_zero</a> (struct <a class="el" href="structblobtype.html">blobtype</a> <a class="el" href="numerical__recipes_8cpp.html#af090b2fbbd2916bfb2e493c5162969d6">b</a>)</td></tr>
<tr class="separator:ga87a45c6b1e8619e08888ab103c1fd7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b970e558ce2e6e3cb9b542c8f1fa058"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Blobs.html#ga6b970e558ce2e6e3cb9b542c8f1fa058">blob_att</a> (double <a class="el" href="numerical__recipes_8cpp.html#a2b83edee7677c7a2b0a4e5ac99baa586">w</a>, struct <a class="el" href="structblobtype.html">blobtype</a> <a class="el" href="numerical__recipes_8cpp.html#af090b2fbbd2916bfb2e493c5162969d6">b</a>)</td></tr>
<tr class="separator:ga6b970e558ce2e6e3cb9b542c8f1fa058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f7631fefa14f5ea33a34e649dad99a2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Blobs.html#ga0f7631fefa14f5ea33a34e649dad99a2">blob_ops</a> (double <a class="el" href="numerical__recipes_8cpp.html#a2b83edee7677c7a2b0a4e5ac99baa586">w</a>, struct <a class="el" href="structblobtype.html">blobtype</a> <a class="el" href="numerical__recipes_8cpp.html#af090b2fbbd2916bfb2e493c5162969d6">b</a>)</td></tr>
<tr class="separator:ga0f7631fefa14f5ea33a34e649dad99a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65b6f10264ad108020eab832bc54e483"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Blobs.html#ga65b6f10264ad108020eab832bc54e483">optimal_CC_grid_relative_size</a> (struct <a class="el" href="structblobtype.html">blobtype</a> <a class="el" href="numerical__recipes_8cpp.html#af090b2fbbd2916bfb2e493c5162969d6">b</a>)</td></tr>
<tr class="separator:ga65b6f10264ad108020eab832bc54e483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e29cec73aae5e98ae56cdfe566b8493"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Blobs.html#ga8e29cec73aae5e98ae56cdfe566b8493">optimal_BCC_grid_relative_size</a> (struct <a class="el" href="structblobtype.html">blobtype</a> <a class="el" href="numerical__recipes_8cpp.html#af090b2fbbd2916bfb2e493c5162969d6">b</a>)</td></tr>
<tr class="separator:ga8e29cec73aae5e98ae56cdfe566b8493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7316736d9a542f44eb2d81dc33e909aa"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Blobs.html#ga7316736d9a542f44eb2d81dc33e909aa">optimal_FCC_grid_relative_size</a> (struct <a class="el" href="structblobtype.html">blobtype</a> <a class="el" href="numerical__recipes_8cpp.html#af090b2fbbd2916bfb2e493c5162969d6">b</a>)</td></tr>
<tr class="separator:ga7316736d9a542f44eb2d81dc33e909aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8e2050314c77dfb98af95f408365bb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structblobtype.html">blobtype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Blobs.html#gac8e2050314c77dfb98af95f408365bb2">best_blob</a> (double alpha_0, double alpha_F, double inc_alpha, double a_0, double a_F, double inc_a, double <a class="el" href="numerical__recipes_8cpp.html#a2b83edee7677c7a2b0a4e5ac99baa586">w</a>, double *target_att, int target_length=1)</td></tr>
<tr class="separator:gac8e2050314c77dfb98af95f408365bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab81ecd64b721b04143708dc10aa4a4bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Blobs.html#gab81ecd64b721b04143708dc10aa4a4bb">footprint_blob</a> (<a class="el" href="classImageOver.html">ImageOver</a> &amp;blobprint, const struct <a class="el" href="structblobtype.html">blobtype</a> &amp;blob, int istep=50, int normalise=0)</td></tr>
<tr class="separator:gab81ecd64b721b04143708dc10aa4a4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade32964792892a00478421dcdba274bf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Blobs.html#gade32964792892a00478421dcdba274bf">sum_blob_Grid</a> (const struct <a class="el" href="structblobtype.html">blobtype</a> &amp;blob, const <a class="el" href="classGrid.html">Grid</a> &amp;grid, const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; *D=NULL)</td></tr>
<tr class="separator:gade32964792892a00478421dcdba274bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8947e150817ff61eebf5187a73985610"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Blobs.html#ga8947e150817ff61eebf5187a73985610">voxel_volume_shape</a> (const <a class="el" href="group__Grids.html#gae3eeb15b316a9800a7c35372dfd57460">GridVolume</a> &amp;vol_blobs, const struct <a class="el" href="structblobtype.html">blobtype</a> &amp;blob, const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; *D, <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; int &gt; &amp;corner1, <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; int &gt; &amp;size)</td></tr>
<tr class="separator:ga8947e150817ff61eebf5187a73985610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga769d35289332d6806a6358b748ecc0a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Blobs.html#ga769d35289332d6806a6358b748ecc0a9">blobs2voxels</a> (const <a class="el" href="group__Grids.html#gae3eeb15b316a9800a7c35372dfd57460">GridVolume</a> &amp;vol_blobs, const struct <a class="el" href="structblobtype.html">blobtype</a> &amp;blob, <a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; *vol_voxels, const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; *D=NULL, int threads=1, int Zdim=0, int Ydim=0, int Xdim=0)</td></tr>
<tr class="separator:ga769d35289332d6806a6358b748ecc0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32723dcca7f313a15c62ba3f8652282a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Blobs.html#ga32723dcca7f313a15c62ba3f8652282a">blobs2space_coefficients</a> (const <a class="el" href="group__Grids.html#gae3eeb15b316a9800a7c35372dfd57460">GridVolume</a> &amp;vol_blobs, const struct <a class="el" href="structblobtype.html">blobtype</a> &amp;blob, <a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; *vol_coefs)</td></tr>
<tr class="separator:ga32723dcca7f313a15c62ba3f8652282a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae235a7c2de134c88fe477b9d98149d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Blobs.html#gaae235a7c2de134c88fe477b9d98149d4">voxels2blobs</a> (const <a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; *vol_voxels, const struct <a class="el" href="structblobtype.html">blobtype</a> &amp;blob, <a class="el" href="group__Grids.html#gae3eeb15b316a9800a7c35372dfd57460">GridVolume</a> &amp;vol_blobs, int grid_type, double grid_relative_size, double <a class="el" href="numerical__recipes_8cpp.html#aca36b09d6e71a60cfa3837d7e24c07ca">lambda</a>, const <a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; *vol_mask=NULL, const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; *D=NULL, double final_error_change=0.01, int tell=0, double R=-1, int threads=1)</td></tr>
<tr class="separator:gaae235a7c2de134c88fe477b9d98149d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94823f436a57fc7e534e04d1829f47a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Blobs.html#ga94823f436a57fc7e534e04d1829f47a5">ART_voxels2blobs_single_step</a> (<a class="el" href="group__Grids.html#gae3eeb15b316a9800a7c35372dfd57460">GridVolume</a> &amp;vol_in, <a class="el" href="group__Grids.html#gae3eeb15b316a9800a7c35372dfd57460">GridVolume</a> *vol_out, const struct <a class="el" href="structblobtype.html">blobtype</a> &amp;blob, const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; *D, double <a class="el" href="numerical__recipes_8cpp.html#aca36b09d6e71a60cfa3837d7e24c07ca">lambda</a>, <a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; *theo_vol, const <a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; *<a class="el" href="lib__vio_8h.html#aa6a42a7e0a69b7da72558548e4ed4331">read_vol</a>, <a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; *corr_vol, const <a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; *mask_vol, double &amp;mean_error, double &amp;max_error, int eq_mode=<a class="el" href="group__Blobs.html#gae1a62943287cc2f243753d3a9d0dcd9d">VARTK</a>, int threads=1)</td></tr>
<tr class="separator:ga94823f436a57fc7e534e04d1829f47a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga8119af50e3fa095d670c01a680d9f2cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define blob_Fourier_val</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="numerical__recipes_8cpp.html#a2b83edee7677c7a2b0a4e5ac99baa586">w</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">blob&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__Blobs.html#gad2a185cd88a0d1a7e22ccbaa01624751">kaiser_Fourier_value</a>(<a class="el" href="numerical__recipes_8cpp.html#a2b83edee7677c7a2b0a4e5ac99baa586">w</a>, blob.radius, blob.alpha, blob.order)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fourier transform of a blob. This function returns the value of the Fourier transform of the blob at a given frequency (w). This frequency must be normalized by the sampling rate. For instance, for computing the Fourier Transform of a blob at 1/Ts (Ts in Amstrongs) you must provide the frequency Tm/Ts, where Tm is the sampling rate.</p>
<p>The Fourier Transform can be computed only for blobs with m=2 or m=0. </p>

</div>
</div>
<a class="anchor" id="ga5a62015b2158b9644950af306dc8b856"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define blob_mass</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">blob</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__Blobs.html#gad30bf1a00f736d5378040c6d4f4e30a5">basvolume</a>(blob.radius, blob.alpha, blob.order,3)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Formula for a volume integral of a blob (n is the blob dimension) </p>

</div>
</div>
<a class="anchor" id="ga0af420e41e9958b9c5b562c1df9a6b9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define blob_proj</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">r, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">blob&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__Blobs.html#gae3586255797a1a110ba99268a050ccef">kaiser_proj</a>(r, blob.radius, blob.alpha, blob.order)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classBlob.html">Blob</a> projection. This function returns the value of the blob line integral through a straight line which passes at a distance 'r' (in Universal System units) from the center of the blob. Remember that a blob is spherically symmetrycal so the only parameter to know this blob line integral is its distance to the center of the blob. It doesn't matter if this distance is larger than the real blob spatial extension, in this case the function returns 0. \ Ex: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;struct blobtype blob; blob.radius = 2; blob.order = 2; blob.alpha = 3.6;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Matrix1D&lt;double&gt; v=vectorR3(1,1,1);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;std::cout &lt;&lt; &quot;Blob line integral through (1,1,1) = &quot; &lt;&lt; blob_proj(v.mod(),blob)</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;     &lt;&lt; std::endl;</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaeba6cc6d681f05be51139d9d5c21a305"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define blob_val</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">r, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">blob&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__Blobs.html#ga1d25336dea0e85d705d18ebdb27f018a">kaiser_value</a>(r, blob.radius, blob.alpha, blob.order)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classBlob.html">Blob</a> value. This function returns the value of a blob at a given distance from its center (in Universal System units). The distance must be always positive. Remember that a blob is spherically symmetrycal so the only parameter to know the blob value at a point is its distance to the center of the blob. It doesn't matter if this distance is larger than the real blob spatial extension, in this case the function returns 0 as blob value. \ Ex: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;struct blobtype blob; blob.radius = 2; blob.order = 2; blob.alpha = 3.6;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Matrix1D&lt;double&gt; v=vectorR3(1,1,1);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;std::cout &lt;&lt; &quot;Blob value at (1,1,1) = &quot; &lt;&lt; blob_val(v.mod(),blob) &lt;&lt; std::endl;</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gad1f8107fe2e79dd5a210df9509ab6055"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SHOW_CONVERSION&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gae1a62943287cc2f243753d3a9d0dcd9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VARTK&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3fbce6fd195e1787971b7b93e82cbbd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VMAXARTK&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga94823f436a57fc7e534e04d1829f47a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ART_voxels2blobs_single_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Grids.html#gae3eeb15b316a9800a7c35372dfd57460">GridVolume</a> &amp;&#160;</td>
          <td class="paramname"><em>vol_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Grids.html#gae3eeb15b316a9800a7c35372dfd57460">GridVolume</a> *&#160;</td>
          <td class="paramname"><em>vol_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structblobtype.html">blobtype</a> &amp;&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>theo_vol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>read_vol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>corr_vol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>mask_vol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>mean_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>max_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eq_mode</em> = <code><a class="el" href="group__Blobs.html#gae1a62943287cc2f243753d3a9d0dcd9d">VARTK</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Voxels &mdash;&gt; Blobs, single step. This is the basic step of the voxels to blobs conversion. It applies an ART step to the blob volume and produces its output in a different (or the same) volume. You must provide the blob structure, lambda and deformation matrix (typical for crystals). The theoretical volume and correction volume are resized inside and are output volumes meaning the conversion from blobs to voxels before this step and the correction applied to the blob volume. The read volume is the one to reproduce with blobs and the mask volume is used to select only one region to adjust.</p>
<p>If the mask is NULL then it is assumed that all voxels in the input voxel volume must be adjusted by the blobs. If the input voxel volume is NULL the it is assumed that it is equal to 0 and only those corresponding to the 1 positions within the mask must be adjusted. An exception is thrown if the mask and voxels volume are both NULL.</p>
<p>Then mean and maximum error committed for each blob are returned.</p>
<p>Valid eq_modes are \VARTK: ART by blocks for volumes. \VMAXARTK: update with the maximum update. </p>

</div>
</div>
<a class="anchor" id="gad30bf1a00f736d5378040c6d4f4e30a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double basvolume </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function actually computing the blob integral </p>

</div>
</div>
<a class="anchor" id="gac8e2050314c77dfb98af95f408365bb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structblobtype.html">blobtype</a> best_blob </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>inc_alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a_F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>inc_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>target_att</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target_length</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Choose the best blob within a region. You must select a resolution limit, the maximum attenuation allowed at that frequency and then the blob with less computational cost is returned. m=2 always. The resolution criterion is given by w (remind that this w=Tm*w(cont)).</p>
<p>If there is no blob meeting the specification then alpha=a=-1. </p>

</div>
</div>
<a class="anchor" id="ga6b970e558ce2e6e3cb9b542c8f1fa058"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double blob_att </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structblobtype.html">blobtype</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attenuation of a blob. The Fourier transform of the blob at w is the Fourier transform at w=0 multiplied by the attenuation. This is the value returned. Remind that the frequency must be normalized by the sampling rate. Ie, Tm*w(cont) </p>

</div>
</div>
<a class="anchor" id="ga87a45c6b1e8619e08888ab103c1fd7f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double blob_freq_zero </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structblobtype.html">blobtype</a>&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classBlob.html">Blob</a> pole. This is the normalized frequency at which the blob goes to 0. </p>

</div>
</div>
<a class="anchor" id="ga0f7631fefa14f5ea33a34e649dad99a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double blob_ops </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structblobtype.html">blobtype</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of operations for a blob. This is a number proportional to the number of operations that ART would need to make a reconstruction with this blob. </p>

</div>
</div>
<a class="anchor" id="ga32723dcca7f313a15c62ba3f8652282a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blobs2space_coefficients </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Grids.html#gae3eeb15b316a9800a7c35372dfd57460">GridVolume</a> &amp;&#160;</td>
          <td class="paramname"><em>vol_blobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structblobtype.html">blobtype</a> &amp;&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>vol_coefs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classBlob.html">Blob</a> coefficients as a voxel volume. This function returns a volume with the blob coefficients in their right position in space. The voxel size is g/2 </p>

</div>
</div>
<a class="anchor" id="ga769d35289332d6806a6358b748ecc0a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blobs2voxels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Grids.html#gae3eeb15b316a9800a7c35372dfd57460">GridVolume</a> &amp;&#160;</td>
          <td class="paramname"><em>vol_blobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structblobtype.html">blobtype</a> &amp;&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>vol_voxels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>D</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Zdim</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Ydim</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Xdim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Blobs &mdash;&gt; Voxels. The voxel size is defined between two coordinates (Gcorner1 and Gcorner2) which accomplish </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;XX(Gcorner1)=MIN(XX(SGcorner1(i)));</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;YY(Gcorner1)=MIN(YY(SGcorner1(i)));</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;ZZ(Gcorner1)=MIN(ZZ(SGcorner1(i)));</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;XX(Gcorner2)=MAX(XX(SGcorner2(i)));</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;YY(Gcorner2)=MAX(YY(SGcorner2(i)));</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;ZZ(Gcorner2)=MAX(ZZ(SGcorner2(i)));</div></div><!-- fragment --><p> where SGcorner1(i) and SGcorner2(i) are the lowest and highest corners of each subgrid. These corners are expressed in Universal coordinates.</p>
<p>This quantity is then enlarged to be an integer voxel position and to take into account that the former computed Gcorner1 and 2 are the furthest centers of blobs, ie, there will be voxels even further affected by these blobs. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Gcorner1 = CEILnD (Gcorner1 - blob.radius);</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Gcorner2 = FLOORnD(Gcorner2 + blob.radius);</div></div><!-- fragment --><p>However, you might give a size, usually set to 0, i.e., no external size. If no size is provided a size is produced such that all blob centers fit into the output volume.</p>
<p>D is a 3x3 matrix specifying a volume deformation. It means that the sample at logical position (i,j,k) is really placed at space position D*(i,j,k)'. </p>

</div>
</div>
<a class="anchor" id="gab81ecd64b721b04143708dc10aa4a4bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void footprint_blob </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classImageOver.html">ImageOver</a> &amp;&#160;</td>
          <td class="paramname"><em>blobprint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structblobtype.html">blobtype</a> &amp;&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>istep</em> = <code>50</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>normalise</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Footprint of a blob. In the actual implementation of the 3D reconstruction one of the most important things to save time is to have a precomputed blob projection. As it is spherically symmetrical all projections from different directions of the same blob happen to be the same. This function makes this precalculation storing it in an oversampled image. This is done so because the blob footprint might not be centered with respect to the universal grid needing so, the footprint at non-integer positions. As parameters to this function you may give the sampling rate in each direction, and an optional normalisation (usually disabled) at the end of the computation which divides the whole image by the sum of the whole image. \ Ex: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;ImageOver             blobprint;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;struct blobtype       blob;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;blob.radius = 1.7;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;blob.order  = 2;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;blob.alpha  = 3.6;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;footprint_blob(blobprint, blob);</div></div><!-- fragment --><p> As the blob radius is 1.7, the function will create a normalised footprint of logical corners (-2,-2) to (2,2) (in the universal coord. system) (this size is the minimum integer number of pixels which contain entirely the blob), with 50 samples each pixel. The real size of the footprint is (550)<a class="el" href="projection_8cpp.html#ab81d9253b246f09be9999505d515d517">x(550)</a>. </p>

</div>
</div>
<a class="anchor" id="gab1c7e82811e94d7957dc0f8891a57cfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double i_n </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bessel function I_n (x), n = 0, 1, 2, ... Use ONLY for small values of n </p>

</div>
</div>
<a class="anchor" id="ga1c16f98dae81ec5758de5d1de321e4a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double i_nph </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bessel function I_(n+1/2) (x), n = 0, 1, 2, ... </p>

</div>
</div>
<a class="anchor" id="ga9ca9464825734b841e8fe3b688d4210b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double in_zeroarg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Limit (z-&gt;0) of (1/z)^n I_n(z) (needed by basvolume) </p>

</div>
</div>
<a class="anchor" id="ga5535ae1ec6293ae20ff93667838ab722"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double inph_zeroarg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Limit (z-&gt;0) of (1/z)^(n+1/2) I_(n+1/2) (z) (needed by basvolume) </p>

</div>
</div>
<a class="anchor" id="gad2a185cd88a0d1a7e22ccbaa01624751"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double kaiser_Fourier_value </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function actually computing the blob Fourier transform. </p>

</div>
</div>
<a class="anchor" id="gae3586255797a1a110ba99268a050ccef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double kaiser_proj </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function actually computing the blob projection. </p>

</div>
</div>
<a class="anchor" id="ga1d25336dea0e85d705d18ebdb27f018a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double kaiser_value </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function actually computing the blob value. </p>

</div>
</div>
<a class="anchor" id="ga8e29cec73aae5e98ae56cdfe566b8493"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double optimal_BCC_grid_relative_size </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structblobtype.html">blobtype</a>&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Optimal BCC grid spastd::cing. This function returns the optimal grid relative size for the blob selected. </p>

</div>
</div>
<a class="anchor" id="ga65b6f10264ad108020eab832bc54e483"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double optimal_CC_grid_relative_size </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structblobtype.html">blobtype</a>&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Optimal CC grid spastd::cing. This function returns the optimal grid relative size for the blob selected. </p>

</div>
</div>
<a class="anchor" id="ga7316736d9a542f44eb2d81dc33e909aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double optimal_FCC_grid_relative_size </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structblobtype.html">blobtype</a>&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Optimal FCC grid spastd::cing. This function returns the optimal grid relative size for the blob selected. </p>

</div>
</div>
<a class="anchor" id="gade32964792892a00478421dcdba274bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double sum_blob_Grid </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structblobtype.html">blobtype</a> &amp;&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGrid.html">Grid</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>D</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sum of a single blob over a grid. As a normalisation factor, the sum of the blob values over a given grid is needed. What this function does is put a blob at coordinate (0,0,0) and sums all the blob values at points of the grid which are inside the blob. It doesn't matter if the grid is compound or not. \ Ex: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// Blob definition</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;struct blobtype       blob;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;blob.radius = 2;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;blob.order  = 2;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;blob.alpha  = 3.6;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;// Grid definition</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;Grid BCCgrid;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;BCCgrid=BCC_grid(1.41,vectorR3(-5,-5,-5),vector_R3( 5, 5, 5));</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;std::cout &lt;&lt; &quot;The sum of a single blob over the grid is &quot; &lt;&lt;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;     &lt;&lt; sum_blob_grid(blob, BCCgrid);</div></div><!-- fragment --><p>D is a 3x3 matrix specifying a volume deformation. It means that the sample at logical position (i,j,k) is really placed at space position D*(i,j,k)'. </p>

</div>
</div>
<a class="anchor" id="ga8947e150817ff61eebf5187a73985610"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void voxel_volume_shape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Grids.html#gae3eeb15b316a9800a7c35372dfd57460">GridVolume</a> &amp;&#160;</td>
          <td class="paramname"><em>vol_blobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structblobtype.html">blobtype</a> &amp;&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>corner1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Voxel shape for a blob volume. Given a blob volume this function returns the logical origin and size for the minimum voxel volume which holds it. See <a class="el" href="group__Blobs.html#ga769d35289332d6806a6358b748ecc0a9">blobs2voxels</a> for an explanation of the limit and V parameters. </p>

</div>
</div>
<a class="anchor" id="gaae235a7c2de134c88fe477b9d98149d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void voxels2blobs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>vol_voxels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structblobtype.html">blobtype</a> &amp;&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Grids.html#gae3eeb15b316a9800a7c35372dfd57460">GridVolume</a> &amp;&#160;</td>
          <td class="paramname"><em>vol_blobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>grid_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>grid_relative_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>vol_mask</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>D</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>final_error_change</em> = <code>0.01</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tell</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>R</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Voxels &mdash;&gt; Blobs. The voxels to blobs procedure is an iterative process resolved by ART as an iterative technique to solve an equation system. The blobs to voxels process is the BASIC way to solve this problem. This applies the whole ART process. You can set a debugging level by setting the flag SHOW_CONVERSION in the tell argument.</p>
<p>If the mask is NULL then it is assumed that all voxels in the input voxel volume must be adjusted by the blobs. If the input voxel volume is NULL the it is assumed that it is equal to 0 and only those corresponding to the 1 positions within the mask must be adjusted.</p>
<p>R is the interest radius. If it is -1 two superimposed grids are created, otherwise a single grid with tilted axis is.</p>
<p>Valid grid types are defined in Some useful grids </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
