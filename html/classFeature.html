<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Xmipp API Documentation: Feature Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xmipp_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Xmipp API Documentation
   &#160;<span id="projectnumber">v20.07</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classFeature-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Feature Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__Phantoms.html">Phantoms</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="phantom_8h_source.html">phantom.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Feature:</div>
<div class="dyncontent">
<div class="center"><img src="classFeature__inherit__graph.png" border="0" usemap="#Feature_inherit__map" alt="Inheritance graph"/></div>
<map name="Feature_inherit__map" id="Feature_inherit__map">
<area shape="rect" id="node2" href="classBlob.html" title="Blob" alt="" coords="5,80,53,107"/>
<area shape="rect" id="node3" href="classGaussian.html" title="Gaussian" alt="" coords="77,80,155,107"/>
<area shape="rect" id="node4" href="classOriented__Feature.html" title="Oriented_Feature" alt="" coords="179,80,301,107"/>
<area shape="rect" id="node10" href="classSphere.html" title="Sphere" alt="" coords="326,80,389,107"/>
<area shape="rect" id="node5" href="classCone.html" title="Cone" alt="" coords="49,155,103,181"/>
<area shape="rect" id="node6" href="classCube.html" title="Cube" alt="" coords="127,155,180,181"/>
<area shape="rect" id="node7" href="classCylinder.html" title="Cylinder" alt="" coords="205,155,275,181"/>
<area shape="rect" id="node8" href="classDCylinder.html" title="DCylinder" alt="" coords="300,155,380,181"/>
<area shape="rect" id="node9" href="classEllipsoid.html" title="Ellipsoid" alt="" coords="405,155,475,181"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Feature:</div>
<div class="dyncontent">
<div class="center"><img src="classFeature__coll__graph.png" border="0" usemap="#Feature_coll__map" alt="Collaboration graph"/></div>
<map name="Feature_coll__map" id="Feature_coll__map">
<area shape="rect" id="node2" href="classMatrix1D.html" title="Matrix1D\&lt; double \&gt;" alt="" coords="5,5,143,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8b8eb9bc2f3759db4f200b37336825c3"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#a8b8eb9bc2f3759db4f200b37336825c3">~Feature</a> ()</td></tr>
<tr class="separator:a8b8eb9bc2f3759db4f200b37336825c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc109c7db1e18439d93e4bf56260e09"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#acfc109c7db1e18439d93e4bf56260e09">prepare</a> ()=0</td></tr>
<tr class="separator:acfc109c7db1e18439d93e4bf56260e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12ffde77862ccfa8f05edcf83318abe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFeature.html">Feature</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#af12ffde77862ccfa8f05edcf83318abe">operator=</a> (const <a class="el" href="classFeature.html">Feature</a> &amp;F)</td></tr>
<tr class="memdesc:af12ffde77862ccfa8f05edcf83318abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment.  <a href="#af12ffde77862ccfa8f05edcf83318abe">More...</a><br /></td></tr>
<tr class="separator:af12ffde77862ccfa8f05edcf83318abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b730e0b4547bcfb383b243aa868136"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#ae2b730e0b4547bcfb383b243aa868136">assign</a> (const <a class="el" href="classFeature.html">Feature</a> &amp;F)</td></tr>
<tr class="separator:ae2b730e0b4547bcfb383b243aa868136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a6e450be06a1ece3d1d97adce9812c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#aa6a6e450be06a1ece3d1d97adce9812c">rotate</a> (const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;E)</td></tr>
<tr class="separator:aa6a6e450be06a1ece3d1d97adce9812c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b02140efd49b5ac5cb4f01d7aff22d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#a9b02140efd49b5ac5cb4f01d7aff22d8">rotate_center</a> (const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;E)</td></tr>
<tr class="separator:a9b02140efd49b5ac5cb4f01d7aff22d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5873e9c913db461359adf4e928a3395"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#ac5873e9c913db461359adf4e928a3395">point_inside</a> (const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;r, <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;aux) const =0</td></tr>
<tr class="separator:ac5873e9c913db461359adf4e928a3395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84045e929f5d93536443e3defb909a78"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#a84045e929f5d93536443e3defb909a78">point_inside</a> (const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;r) const </td></tr>
<tr class="separator:a84045e929f5d93536443e3defb909a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3de0cabb49594eb85b5b344f4ca206a"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#ad3de0cabb49594eb85b5b344f4ca206a">density_inside</a> (const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;r, <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;aux) const =0</td></tr>
<tr class="separator:ad3de0cabb49594eb85b5b344f4ca206a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86351acf111729baa92dfc2a5b659ba7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#a86351acf111729baa92dfc2a5b659ba7">voxel_inside</a> (const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;r, <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;aux1, <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;aux2) const </td></tr>
<tr class="separator:a86351acf111729baa92dfc2a5b659ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447b25305ed4c7e3e77fcb238dca6add"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#a447b25305ed4c7e3e77fcb238dca6add">voxel_inside</a> (const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;r) const </td></tr>
<tr class="separator:a447b25305ed4c7e3e77fcb238dca6add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589dbf4e23cf03f4e4eea36b57c39cf3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#a589dbf4e23cf03f4e4eea36b57c39cf3">voxel_inside_by_normalized_density</a> (const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;r, <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;aux1, <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;aux2) const </td></tr>
<tr class="separator:a589dbf4e23cf03f4e4eea36b57c39cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1232deb6df56547d20f56b954a4b7e38"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#a1232deb6df56547d20f56b954a4b7e38">intersects_sphere</a> (const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;r, double radius, <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;aux1, <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;aux2, <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;aux3) const </td></tr>
<tr class="separator:a1232deb6df56547d20f56b954a4b7e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5acc3cedbdb9dd8b5bea4285e5265ff2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#a5acc3cedbdb9dd8b5bea4285e5265ff2">intersects_sphere</a> (const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;r, double radius) const </td></tr>
<tr class="separator:a5acc3cedbdb9dd8b5bea4285e5265ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb35b9110971e737e132c90575671ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFeature.html">Feature</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#a8fb35b9110971e737e132c90575671ba">encircle</a> (double radius=0) const </td></tr>
<tr class="separator:a8fb35b9110971e737e132c90575671ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1c9056e82930b80b6eddc70e9f251b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classFeature.html">Feature</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#a2f1c9056e82930b80b6eddc70e9f251b">scale</a> (double factor) const =0</td></tr>
<tr class="separator:a2f1c9056e82930b80b6eddc70e9f251b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21e1c64ba88596e390eb35f4dc1dd31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFeature.html">Feature</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#ac21e1c64ba88596e390eb35f4dc1dd31">background</a> (int back_mode, double back_param) const </td></tr>
<tr class="separator:ac21e1c64ba88596e390eb35f4dc1dd31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22505c1face2430b74fce3d331aeceab"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#a22505c1face2430b74fce3d331aeceab">intersection</a> (const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;<a class="el" href="group__FringeProcessing.html#gad71cd7f2325be81202279ed730355092">direction</a>, const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;passing_point, <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;r, <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;<a class="el" href="numerical__recipes_8cpp.html#a6277e2a7446059985dc9bcf0a4ac1a8f">u</a>) const =0</td></tr>
<tr class="separator:a22505c1face2430b74fce3d331aeceab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b504e31e69cd03aa61de4916f943f2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#a43b504e31e69cd03aa61de4916f943f2">intersection</a> (const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;<a class="el" href="group__FringeProcessing.html#gad71cd7f2325be81202279ed730355092">direction</a>, const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;passing_point) const </td></tr>
<tr class="separator:a43b504e31e69cd03aa61de4916f943f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5db26cf1ca5d7d818ed38f62de628b"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#a9c5db26cf1ca5d7d818ed38f62de628b">volume</a> () const =0</td></tr>
<tr class="separator:a9c5db26cf1ca5d7d818ed38f62de628b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb596dd2b88936855a7b1d4f094c909"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#aceb596dd2b88936855a7b1d4f094c909">mean_variance_in_plane</a> (<a class="el" href="classImage.html">Image</a>&lt; double &gt; *V, double <a class="el" href="numerical__recipes_8cpp.html#aa508e3dbd0e86258b5c69e8a8b6b8295">z</a>, double &amp;mean, double &amp;var)</td></tr>
<tr class="separator:aceb596dd2b88936855a7b1d4f094c909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ddafb2c72f4c09640e9b1881b1d6b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#ac3ddafb2c72f4c09640e9b1881b1d6b8">project_to</a> (<a class="el" href="classProjection.html">Projection</a> &amp;P, const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;VP, const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;PV) const </td></tr>
<tr class="separator:ac3ddafb2c72f4c09640e9b1881b1d6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6045b395ac5dd1cb15a5a083427fd44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#aa6045b395ac5dd1cb15a5a083427fd44">corners</a> (const <a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; &amp;V, <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;corner1, <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;corner2)</td></tr>
<tr class="separator:aa6045b395ac5dd1cb15a5a083427fd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d1d87a571d721c2b75023b8c63544b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#ac0d1d87a571d721c2b75023b8c63544b">draw_in</a> (<a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; &amp;V, int color_mode=<a class="el" href="phantom_8h.html#a02c5e2eafaed44878fd8e6c54c8dde4d">INTERNAL</a>, double colour=-1)</td></tr>
<tr class="separator:ac0d1d87a571d721c2b75023b8c63544b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92c06440e165f40c303e893564326f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#af92c06440e165f40c303e893564326f3">sketch_in</a> (<a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; &amp;V, double colour=2)</td></tr>
<tr class="separator:af92c06440e165f40c303e893564326f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747114489bb6e6fcfe2f8d196d7f6ec1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#a747114489bb6e6fcfe2f8d196d7f6ec1">shift</a> (double shiftX, double shiftY, double shiftZ)</td></tr>
<tr class="separator:a747114489bb6e6fcfe2f8d196d7f6ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9c3df179e1616f1fd2a897f166c7ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#a7e9c3df179e1616f1fd2a897f166c7ea">selfApplyGeometry</a> (const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;A)</td></tr>
<tr class="separator:a7e9c3df179e1616f1fd2a897f166c7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d945caba1be77294c0b911a14324e0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#a89d945caba1be77294c0b911a14324e0">feat_printf</a> (FILE *fh) const =0</td></tr>
<tr class="separator:a89d945caba1be77294c0b911a14324e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69f549ad8ddae687fcb42f2f981832b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#ac69f549ad8ddae687fcb42f2f981832b">feat_printm</a> (<a class="el" href="classMetaData.html">MetaData</a> &amp;MD, size_t id)=0</td></tr>
<tr class="separator:ac69f549ad8ddae687fcb42f2f981832b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade99a9be8ccf32211771399d3f9e607f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#ade99a9be8ccf32211771399d3f9e607f">readCommon</a> (char *line)</td></tr>
<tr class="separator:ade99a9be8ccf32211771399d3f9e607f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e7afa434f27b8d408ce5eefa6b3c56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#a83e7afa434f27b8d408ce5eefa6b3c56">readCommon</a> (<a class="el" href="classMDRow.html">MDRow</a> &amp;row)</td></tr>
<tr class="separator:a83e7afa434f27b8d408ce5eefa6b3c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1843de345993d7491c653d769ee029b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#a1843de345993d7491c653d769ee029b6">read</a> (<a class="el" href="classMDRow.html">MDRow</a> &amp;row)</td></tr>
<tr class="separator:a1843de345993d7491c653d769ee029b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3167f4a843950a74b48e13af71fc3f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#acd3167f4a843950a74b48e13af71fc3f">read_specific</a> (const std::vector&lt; double &gt; &amp;vector)=0</td></tr>
<tr class="separator:acd3167f4a843950a74b48e13af71fc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:abaec53ba8fbe169f88bfeb526d56f7a5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#abaec53ba8fbe169f88bfeb526d56f7a5">Type</a></td></tr>
<tr class="separator:abaec53ba8fbe169f88bfeb526d56f7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca340a4eb8c5da25ffe1ab3958e1548"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#a7ca340a4eb8c5da25ffe1ab3958e1548">Add_Assign</a></td></tr>
<tr class="separator:a7ca340a4eb8c5da25ffe1ab3958e1548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cef017ac20ba675d36573449b186579"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#a2cef017ac20ba675d36573449b186579">Density</a></td></tr>
<tr class="separator:a2cef017ac20ba675d36573449b186579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45423ae0a78ea69cbf18bf69ebd13119"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#a45423ae0a78ea69cbf18bf69ebd13119">Center</a></td></tr>
<tr class="separator:a45423ae0a78ea69cbf18bf69ebd13119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6171dbc2a0f64c2b7c31fb91573a75c1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#a6171dbc2a0f64c2b7c31fb91573a75c1">max_distance</a></td></tr>
<tr class="separator:a6171dbc2a0f64c2b7c31fb91573a75c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a1f194860a9611e66a9a1cd196a9ad469"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFeature.html#a1f194860a9611e66a9a1cd196a9ad469">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classFeature.html">Feature</a> *F)</td></tr>
<tr class="separator:a1f194860a9611e66a9a1cd196a9ad469"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classFeature.html">Feature</a> superclass. This is a superclass from which all features (cones, cylinders, ...) inherit. It contains all general information common to all feature classes, then the subclasses give the specific parameters for the feature. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8b8eb9bc2f3759db4f200b37336825c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Feature::~Feature </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae2b730e0b4547bcfb383b243aa868136"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Feature::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFeature.html">Feature</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Another function for assigmnet. </p>

</div>
</div>
<a class="anchor" id="ac21e1c64ba88596e390eb35f4dc1dd31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFeature.html">Feature</a> * Feature::background </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>back_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>back_param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pointer to a feature which is the background of the actual one. You can specify two ways of computing the background, either as a sphere surrounding the feature or as an enlarged version of the feature. This is chosen giving the modes ENLARGE_MODE or SPHERE_MODE. Depending on the mode used the background parameter is understood as the sphere radius or as the scaling factor. </p>

</div>
</div>
<a class="anchor" id="aa6045b395ac5dd1cb15a5a083427fd44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Feature::corners </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>corner1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>corner2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define 3D corners for a feature. This function returns two Z3 points where the feature is confined. The volume borders are taken into account and you might make a for using these two values like this: \Ex: </p><div class="fragment"><div class="line">F.corners(V,corner1,corner2);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="numerical__recipes_8cpp.html#a3cea5ad1d3a8a229f9483e49cc2c6656">k</a>=<a class="code" href="group__Vectors.html#gab88d1e959fb58c03aa1f04f1e4a7d452">ZZ</a>(corner1); <a class="code" href="numerical__recipes_8cpp.html#a3cea5ad1d3a8a229f9483e49cc2c6656">k</a>&lt;=<a class="code" href="group__Vectors.html#gab88d1e959fb58c03aa1f04f1e4a7d452">ZZ</a>(corner2); <a class="code" href="numerical__recipes_8cpp.html#a3cea5ad1d3a8a229f9483e49cc2c6656">k</a>++)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="project__crystal_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=<a class="code" href="group__Vectors.html#ga8b0ce0c5282ce1bae56cc1f9ed4b6a5f">YY</a>(corner1); <a class="code" href="project__crystal_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;=<a class="code" href="group__Vectors.html#ga8b0ce0c5282ce1bae56cc1f9ed4b6a5f">YY</a>(corner2); <a class="code" href="project__crystal_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>++)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> <a class="code" href="project__crystal_8cpp.html#aae82a1338cf72eb9a1cc7043f569537e">j</a>=<a class="code" href="group__Vectors.html#ga7dce99001bf2a5ec705503346b6fec85">XX</a>(corner1); <a class="code" href="project__crystal_8cpp.html#aae82a1338cf72eb9a1cc7043f569537e">j</a>&lt;=<a class="code" href="group__Vectors.html#ga7dce99001bf2a5ec705503346b6fec85">XX</a>(corner2); <a class="code" href="project__crystal_8cpp.html#aae82a1338cf72eb9a1cc7043f569537e">j</a>++) {</div><div class="line">            ...</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ad3de0cabb49594eb85b5b344f4ca206a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double Feature::density_inside </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>aux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Speeded up density inside a feature, VIRTUAL!!. This function MUST be implemented for each subclass with NON constant density as blobs and tells you if a point is inside the feature or not plus give you information about the density of the feature at that point. If the point is inside returns 1 multiplied by the density of the NORMALIZED feature and if not, returns 0. The point is given in the vector r, and aux is an auxiliar vector with dimension 3 (must be externally resized) used to do some computations. This auxiliar vector must be supplied in order to gain speed as no memory allocating and freeing is needed. </p>

<p>Implemented in <a class="el" href="classCone.html#ae0067f5f69f88d58adb70da753a495c7">Cone</a>, <a class="el" href="classEllipsoid.html#a8212cac7bd708d17d63a2acd1930a7c7">Ellipsoid</a>, <a class="el" href="classCube.html#a212b748fad93c35d2bd92ab4b0f58c64">Cube</a>, <a class="el" href="classDCylinder.html#a4e5d38ffafe33f94c89d82c85def8990">DCylinder</a>, <a class="el" href="classCylinder.html#a469c56e2eee95279f22113e5cc843006">Cylinder</a>, <a class="el" href="classGaussian.html#acb4922e4c01404fdbdfb355e0dac19a8">Gaussian</a>, <a class="el" href="classBlob.html#ac8824826aeb174e873c838464f91933b">Blob</a>, and <a class="el" href="classSphere.html#a9741b622bd8228d56ea9d8584c7d99d1">Sphere</a>.</p>

</div>
</div>
<a class="anchor" id="ac0d1d87a571d721c2b75023b8c63544b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Feature::draw_in </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>color_mode</em> = <code><a class="el" href="phantom_8h.html#a02c5e2eafaed44878fd8e6c54c8dde4d">INTERNAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>colour</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draw a feature in a Volume. This function draws a feature in a volume (*V). The word "colour" is a little misleading as the colour really refers to a grey-level global density. Ie, the default mode (INTERNAL) draws the feature with its own density and discards the "colour" given in the function call. However, you may change this colour, set a new global density and draw the volume with this given density. This option is useful to generate easily a labelled volume.</p>
<p>The Add-Assign behaviour is the one of the feature if the colour is internally defined, or Assign if the colour is externally given. In the assign behaviour a voxel value is assigned to the volume if the voxel there is smaller than the value we pretend to assign.</p>
<p>A voxel is drawn with a colour proportional to the number of Vertex inside the features. The volume is not cleaned at the beginning. \ Ex: </p><div class="fragment"><div class="line"><a class="code" href="numerical__recipes_8cpp.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.draw_in(V)              --&gt; Internal density</div><div class="line"><a class="code" href="numerical__recipes_8cpp.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.draw_in(V,<a class="code" href="phantom_8h.html#a02c5e2eafaed44878fd8e6c54c8dde4d">INTERNAL</a>,0.5) --&gt; Internal density, 0.5 is discarded</div><div class="line"><a class="code" href="numerical__recipes_8cpp.html#a633de4b0c14ca52ea2432a3c8a5c4c31">f</a>.draw_in(V,<a class="code" href="phantom_8h.html#af3fe37c1cda80aa7202b5a3bb7557dc9">EXTERNAL</a>,0.5) --&gt; External density=0.5</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a8fb35b9110971e737e132c90575671ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFeature.html">Feature</a> * Feature::encircle </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a sphere envolving the feature. This function returns a pointer to a feature (a sphere) with the same center, density, and feature behaviour as the given feature. The radius could be given in voxel units or if you leave it 0 then the radius is computed as 1.5 times the <a class="el" href="classFeature.html#a6171dbc2a0f64c2b7c31fb91573a75c1">max_distance</a> of this feature </p>

</div>
</div>
<a class="anchor" id="a89d945caba1be77294c0b911a14324e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Feature::feat_printf </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fh</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print the feature in the <a class="el" href="classFeature.html">Feature</a> format, VIRTUAL!!!. This function prints the feature in the Standard <a class="el" href="classFeature.html">Feature</a> format (readable by this library). Notice that the standard format is different for each specific feature. See <a class="el" href="group__Phantoms.html">Phantoms</a> for more information about the supported file format. </p>

<p>Implemented in <a class="el" href="classCone.html#a776a4b5ec72c041fb29eecfa50c30bbb">Cone</a>, <a class="el" href="classEllipsoid.html#aa0e30c327f11c4c8d63b7d0b554e621a">Ellipsoid</a>, <a class="el" href="classCube.html#ab5c96e1ce556e60195f83860bbd8a4a0">Cube</a>, <a class="el" href="classDCylinder.html#a00c75be73fb720f1dd78a76c6cfcaea1">DCylinder</a>, <a class="el" href="classCylinder.html#ac54b0cae09a14b3132a94264184befad">Cylinder</a>, <a class="el" href="classGaussian.html#a71fb6f8e629b623549a0773488d718c7">Gaussian</a>, <a class="el" href="classBlob.html#ae4a823e90239b33b03e47911f8b79200">Blob</a>, and <a class="el" href="classSphere.html#ad693b5181af61744ed72acb637f7dabc">Sphere</a>.</p>

</div>
</div>
<a class="anchor" id="ac69f549ad8ddae687fcb42f2f981832b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Feature::feat_printm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMetaData.html">MetaData</a> &amp;&#160;</td>
          <td class="paramname"><em>MD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classCone.html#a5ea193ab7dcf761c191644e5017f6a51">Cone</a>, <a class="el" href="classEllipsoid.html#ab16e3229cdea09237b43044336dd9b32">Ellipsoid</a>, <a class="el" href="classCube.html#af1fcc4a26fa286f82d27170a4aa8fa19">Cube</a>, <a class="el" href="classDCylinder.html#a77ec713babd4dbb146c960e6c1e08986">DCylinder</a>, <a class="el" href="classCylinder.html#a99883fb5b6529ad33bee18890b1eaae4">Cylinder</a>, <a class="el" href="classGaussian.html#a482e23a74b1719dc8d182fe5e77921b6">Gaussian</a>, <a class="el" href="classBlob.html#ae0376e3ef93c61fb3f7a97231872ab0a">Blob</a>, and <a class="el" href="classSphere.html#a855b5c999c19ef04c1f1d1151fb83bbb">Sphere</a>.</p>

</div>
</div>
<a class="anchor" id="a22505c1face2430b74fce3d331aeceab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double Feature::intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>passing_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Speeded Up intersection of a feature with a ray, VIRTUAL!!!. This function returns the length of the intersection between the ray defined by its direction and a passing point and the actual feature (whose center and dimensions are known by itself).</p>
<p>r and u are auxiliar vectors of dimension 3, they must be supplied in order to gain speed. r is the passing point expressed in the feature coordinate system, and u is the direction in the same coordinate system. </p>

<p>Implemented in <a class="el" href="classCone.html#ac63fd9138e49b2bf75ede6d2a8a046aa">Cone</a>, <a class="el" href="classEllipsoid.html#a10e92da194091eddbc5a2ff0660f70aa">Ellipsoid</a>, <a class="el" href="classCube.html#a10c98844709a3a0354337912e2caa88c">Cube</a>, <a class="el" href="classDCylinder.html#ad399207ca2ec87cf7844a717b5b1e01f">DCylinder</a>, <a class="el" href="classCylinder.html#a1de2a6f65833918f8a5875670ade0448">Cylinder</a>, <a class="el" href="classGaussian.html#a38b5029d1c4ce97eb8cf2bbffb67dbc2">Gaussian</a>, <a class="el" href="classBlob.html#af8457d914454613a3a6cbf06e6cb0902">Blob</a>, and <a class="el" href="classSphere.html#a6bccd74d8b60e2f0860c7a92f877416c">Sphere</a>.</p>

</div>
</div>
<a class="anchor" id="a43b504e31e69cd03aa61de4916f943f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Feature::intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>passing_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Intersection of a feature with a ray. This function does the same as the previous one but you needn't provide extra auxiliar vectors. </p>

</div>
</div>
<a class="anchor" id="a1232deb6df56547d20f56b954a4b7e38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Feature::intersects_sphere </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>aux1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>aux2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>aux3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Speeded up sphere intersecting feature. This function returns TRUE if a sphere of a given radius has any voxel inside this feature. r is the center of the sphere in R3. This speeded up function needs two vectors with dimension 3 externally resized. </p>

</div>
</div>
<a class="anchor" id="a5acc3cedbdb9dd8b5bea4285e5265ff2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Feature::intersects_sphere </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSphere.html">Sphere</a> intersecting feature. This function is based in the previous one. It makes the same but you needn't supply the auxiliar vectors. </p>

</div>
</div>
<a class="anchor" id="aceb596dd2b88936855a7b1d4f094c909"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Feature::mean_variance_in_plane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classImage.html">Image</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mean and variance in a given plane. Given a plane z=z0, this function returns the mean and variance values of the volume (*V) in the voxels inside this feature. A voxel is considered to belong to the feature if it is totally inside the feature. If the plane is outside the volume scope the result is mean=variance=0 </p>

</div>
</div>
<a class="anchor" id="af12ffde77862ccfa8f05edcf83318abe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFeature.html">Feature</a> &amp; Feature::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFeature.html">Feature</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment. </p>

</div>
</div>
<a class="anchor" id="ac5873e9c913db461359adf4e928a3395"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Feature::point_inside </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>aux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Speeded up point inside a feature, VIRTUAL!!. This function MUST be implemented for each subclass and tells you if a point is inside the feature or not. If the point is inside returns 1 and if not, returns 0. The point is given in the vector r, and aux is an auxiliar vector with dimension 3 (must be externally resized) used to do some computations. This auxiliar vector must be supplied in order to gain speed as no memory allocating and freeing is needed. </p>

<p>Implemented in <a class="el" href="classCone.html#a95ee9c17466223262e1e33dcfd0cb1da">Cone</a>, <a class="el" href="classEllipsoid.html#a21ecc6f1f34389a715ba3390d65653f3">Ellipsoid</a>, <a class="el" href="classCube.html#a400ddf752a005fb58ded557936e0705f">Cube</a>, <a class="el" href="classDCylinder.html#a3ae99c62f5da034e91ecf73dc8a716ee">DCylinder</a>, <a class="el" href="classCylinder.html#a519d31de99a78f4a492c760d41c0bc20">Cylinder</a>, <a class="el" href="classGaussian.html#a35cae4a0015af8aaff4d53becee88d9c">Gaussian</a>, <a class="el" href="classBlob.html#a7e1b66601b69074da2c91942e5cc29cd">Blob</a>, and <a class="el" href="classSphere.html#a075dad5d3545e05e394789f1779b004d">Sphere</a>.</p>

</div>
</div>
<a class="anchor" id="a84045e929f5d93536443e3defb909a78"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Feature::point_inside </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="structPoint.html">Point</a> inside a feature. This function is based in the previous one. It makes the same but you needn't supply the auxiliar vector. </p>

</div>
</div>
<a class="anchor" id="acfc109c7db1e18439d93e4bf56260e09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Feature::prepare </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prepare feature for work. This function computes the maximum distance and possibly the <a class="el" href="classEuler.html">Euler</a> and inverse <a class="el" href="classEuler.html">Euler</a> matrices. </p>

<p>Implemented in <a class="el" href="classCone.html#a5d4c7663ac6aab8c3f19b82c182c32bb">Cone</a>, <a class="el" href="classEllipsoid.html#a5a1ff53cbbbb4b51aeae6be7ff660b60">Ellipsoid</a>, <a class="el" href="classCube.html#a4e6254f3343eeb377e60297eeee6c75a">Cube</a>, <a class="el" href="classDCylinder.html#a6a393f2cb726b31e00d4d4e3b7cb7d56">DCylinder</a>, <a class="el" href="classCylinder.html#acae1af3d90b0b22d975613491306da5a">Cylinder</a>, <a class="el" href="classGaussian.html#a06e63a884493d3fd1da88aa6e0b40c3e">Gaussian</a>, <a class="el" href="classBlob.html#ad6f639e88175561bb575fb38373246fd">Blob</a>, and <a class="el" href="classSphere.html#a13a4794da6b7099369c6e691fff7a289">Sphere</a>.</p>

</div>
</div>
<a class="anchor" id="ac3ddafb2c72f4c09640e9b1881b1d6b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Feature::project_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classProjection.html">Projection</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>VP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>PV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Project feature onto a projection plane. <a class="el" href="classProjection.html">Projection</a> is a class itself which has got inside the direction of projection. The projection plane is not cleaned (set all values to 0) when entering this function, but the projection of this feature is added to the already stored one. The projection plane is supposed to have its logical origin in the right place (normally, the middle of the image) before entering the function. An oversampling technique is used in order to produce better projections, the projection in one pixel is computed from the value of 4 points near the pixel, you can modify the subsampling value (actually 2x2=4) by changing a constant at the beginning of the function.</p>
<p>The matrix VP (3x3) is used to define how to relate a point in the 3D universal coordinate to the projection plane. So a point ru in the universal coordinate system, projects to VP*r. PV must be the inverse of the forwarding projection matrix. </p>

</div>
</div>
<a class="anchor" id="a1843de345993d7491c653d769ee029b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Feature::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMDRow.html">MDRow</a> &amp;&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acd3167f4a843950a74b48e13af71fc3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Feature::read_specific </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a feature from a file, VIRTUAL!!!. The format must be the one given in <a class="el" href="group__Phantoms.html">Phantoms</a>, and each subclass must implement its own I/O routines. These routines must fill only the non common part of the feature description, but they receive the whole line with the description. </p>

<p>Implemented in <a class="el" href="classCone.html#a8f51c3c5cb74007970a300e3ed18f1af">Cone</a>, <a class="el" href="classEllipsoid.html#a96fa115eef89fd6d9b6c3d5d4909f9db">Ellipsoid</a>, <a class="el" href="classCube.html#a4a3e9b9cfff9b00d68ad7d1a0dc700a8">Cube</a>, <a class="el" href="classDCylinder.html#addc73e46e722f9368854556bf39c0e59">DCylinder</a>, <a class="el" href="classCylinder.html#aa18b0207ade53ec1fa05dc86f13fd38c">Cylinder</a>, <a class="el" href="classGaussian.html#ab679ded100e093c411057e222589ea08">Gaussian</a>, <a class="el" href="classBlob.html#a7020bb866e8d4ce118cc65eb33f05706">Blob</a>, and <a class="el" href="classSphere.html#a79f36d82f454370f9e1d4677bb63a3e1">Sphere</a>.</p>

</div>
</div>
<a class="anchor" id="ade99a9be8ccf32211771399d3f9e607f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Feature::readCommon </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read common part of the feature description. The common part is the feature type, the behaviour, density and center. The description is passed as a line. Exceptions are thrown if the description doesn't conform the standard specification. </p>

</div>
</div>
<a class="anchor" id="a83e7afa434f27b8d408ce5eefa6b3c56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Feature::readCommon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMDRow.html">MDRow</a> &amp;&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa6a6e450be06a1ece3d1d97adce9812c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Feature::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rotate the whole feature. Rotate this feature using a rotation matrix. The center as well as the feature itself is rotated. </p>

<p>Reimplemented in <a class="el" href="classOriented__Feature.html#a53861bab42165b2b19d2ffceb7f73f6d">Oriented_Feature</a>.</p>

</div>
</div>
<a class="anchor" id="a9b02140efd49b5ac5cb4f01d7aff22d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Feature::rotate_center </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rotate only the center. Rotate the center of this feature only around the phantom center </p>

</div>
</div>
<a class="anchor" id="a2f1c9056e82930b80b6eddc70e9f251b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classFeature.html">Feature</a>* Feature::scale </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a scaled version of this feature, VIRTUAL!!!. This function returns a pointer to a feature (of the same type as the feature for which the function was called, ie, if you scale a sphere the result is a sphere, if you scale a cone, the result is a cone, ...) that is a scaled version of the actual feature (see each specific implementation to see which is the relatioship between the two features). This function is useful to define backgrounds with the same shape of the given feature. </p>

<p>Implemented in <a class="el" href="classCone.html#adee4566bb1a976098f2892c94cd161b2">Cone</a>, <a class="el" href="classEllipsoid.html#a38e152eb65e485ceaf85b5b4fb22057c">Ellipsoid</a>, <a class="el" href="classCube.html#a4a9ea8cc21f2b95c662f93917bbb6793">Cube</a>, <a class="el" href="classDCylinder.html#a9f9aaed4c799a1bdbf71ef9e746815d8">DCylinder</a>, <a class="el" href="classCylinder.html#a33cf6dfdaf55e59458f1ed361b50404c">Cylinder</a>, <a class="el" href="classGaussian.html#a2d5716bffc1da521024726c46e4e8840">Gaussian</a>, <a class="el" href="classBlob.html#a359fba48f25a8f8a1bdf067b9bf892a2">Blob</a>, and <a class="el" href="classSphere.html#a8d3590d3f2afda31589e95c335714b03">Sphere</a>.</p>

</div>
</div>
<a class="anchor" id="a7e9c3df179e1616f1fd2a897f166c7ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Feature::selfApplyGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply a general geometric transformation. The transformation must be defined by a 4x4 matrix that can be generated using the geometric functions in xmippGeometry or xmippMatrix2D. The matrix must be the desired transformation (i.e., new coordinate=A*old_coordinate. Don't worry because the selfApplyGeometry of <a class="el" href="classPhantom.html">Phantom</a> take cares of passing to this function the appropriate matrix. No check is done about the size of A.</p>
<p>Only the center is transformed, the feature will keep the same size. </p>

</div>
</div>
<a class="anchor" id="a747114489bb6e6fcfe2f8d196d7f6ec1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Feature::shift </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shiftX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shiftY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shiftZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shift. Shift the feature a given amount of voxels. The new center is the old center plus the given shift, and that's all </p>

</div>
</div>
<a class="anchor" id="af92c06440e165f40c303e893564326f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Feature::sketch_in </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>colour</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draw the surface of the feature. This function draws the surface of the feature at the given volume. A voxel is said to belong to the surface if the number of corners inside the feature meets 1&lt;=n&lt;=7. The default gray_level with which voxels will be drawn is 2 (normally higher than the usual volume grey levels, and the behaviour of the voxels drawn is Assign. </p>

</div>
</div>
<a class="anchor" id="a9c5db26cf1ca5d7d818ed38f62de628b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double Feature::volume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Volume of the feature in (voxel units) , VIRTUAL!!!. This function returns the volume of each feature supposing that a voxel is of size 1x1x1. </p>

<p>Implemented in <a class="el" href="classCone.html#a6a4ebc702c82e30820d4fbb37fb08018">Cone</a>, <a class="el" href="classEllipsoid.html#aab1924f47700f3097e4804bf6b201d6e">Ellipsoid</a>, <a class="el" href="classCube.html#a69345e6485299539f2552c4f4cdf7b2f">Cube</a>, <a class="el" href="classDCylinder.html#a33e730e1112be7a2f7f314a9bbeaba99">DCylinder</a>, <a class="el" href="classCylinder.html#a767d540b2da13224589b36824bdec83b">Cylinder</a>, <a class="el" href="classGaussian.html#a92655897707c9acda9e83a6ae6e2e3fd">Gaussian</a>, <a class="el" href="classBlob.html#aeaac027bf52567643e57107fead05167">Blob</a>, and <a class="el" href="classSphere.html#aa15774662e1bd8ee2ff9344589bda2e3">Sphere</a>.</p>

</div>
</div>
<a class="anchor" id="a86351acf111729baa92dfc2a5b659ba7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Feature::voxel_inside </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>aux1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>aux2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Speeded up voxel inside a feature. A voxel is compound of 8 subvoxels. This function returns the number of subvoxel centers falling inside the feature. The voxel size is supposed to be 1, and r is the center of the voxel in R3. This speeded up function needs two vectors with dimension 3 externally resized. </p>

</div>
</div>
<a class="anchor" id="a447b25305ed4c7e3e77fcb238dca6add"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Feature::voxel_inside </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Voxel inside a feature. This function is based in the previous one. It makes the same but you needn't supply the auxiliar vectors. </p>

</div>
</div>
<a class="anchor" id="a589dbf4e23cf03f4e4eea36b57c39cf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Feature::voxel_inside_by_normalized_density </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>aux1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>aux2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A voxel is compound of 8 subvoxels. This function returns the number of subvoxel centers falling inside the feature multiplied by the normalized feature density. That is, the value of the density is always 1 at the origin The voxel size is supposed to be 1, and r is the center of the voxel in R3. This speeded up function needs two vectors with dimension 3 externally resized. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a1f194860a9611e66a9a1cd196a9ad469"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFeature.html">Feature</a> *&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Show feature not in the standard format but more informatively. This function is based on the std::cout &lt;&lt; ... of each subclass. First shows the common part of the feature and then its specific part. Be careful that you must show a pointer to the feature!! \ Ex: <a class="el" href="classSphere.html">Sphere</a> sphere; std::cout &lt;&lt; (<a class="el" href="classFeature.html">Feature</a> *) &amp;sphere; </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a7ca340a4eb8c5da25ffe1ab3958e1548"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char Feature::Add_Assign</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classFeature.html">Feature</a> behaviour. This flag indicates how the feature behaves inside the voxel volume. If this flag is set to '+' then the voxels occupied by this feature are incremented with the feature value. If the flag is set to '=' then the voxels are set to to the same value of the feature. </p>

</div>
</div>
<a class="anchor" id="a45423ae0a78ea69cbf18bf69ebd13119"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix1D.html">Matrix1D</a>&lt;double&gt; Feature::Center</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Center of the feature. The center of the feature is understood differently according to the specific class, see them to know exactly how this value is interpreted. </p>

</div>
</div>
<a class="anchor" id="a2cef017ac20ba675d36573449b186579"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Feature::Density</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classFeature.html">Feature</a> Density. Density of the feature in grey level values. It needn't be between 0 and 1, or 0 and 255. What is more, it can be even negative, and so you can build holes inside volumes. </p>

</div>
</div>
<a class="anchor" id="a6171dbc2a0f64c2b7c31fb91573a75c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Feature::max_distance</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum distance from the center. This value is a precalculated and tells the maximum distance from any point belonging to the feature to its center. This is used to speed up some functions not considering voxels which we know are beyond the scope of this feature. </p>

</div>
</div>
<a class="anchor" id="abaec53ba8fbe169f88bfeb526d56f7a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Feature::Type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classFeature.html">Feature</a> type. A three letters string telling what kind of feature this object is. For example, "cyl", "con", "cub", ... See the specific classes to know exactly which is each label. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/yunior/Yunior/Projects/Scipion/COSS/xmipp-bundle/src/xmipp/libraries/data/<a class="el" href="phantom_8h_source.html">phantom.h</a></li>
<li>/home/yunior/Yunior/Projects/Scipion/COSS/xmipp-bundle/src/xmipp/libraries/data/<a class="el" href="phantom_8cpp.html">phantom.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
