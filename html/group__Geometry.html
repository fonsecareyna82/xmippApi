<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Xmipp: Geometry</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="xmipp_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Xmipp
   &#160;<span id="projectnumber">v20.07</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Geometry</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFitPoint.html">FitPoint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfit__point2D.html">fit_point2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBspline__model.html">Bspline_model</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Geometrical operations</h2></td></tr>
<tr class="memitem:gade8f7976e3d84a594d4728bf8f4c029e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#gade8f7976e3d84a594d4728bf8f4c029e">Uproject_to_plane</a> (const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;point, const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;<a class="el" href="group__FringeProcessing.html#gad71cd7f2325be81202279ed730355092">direction</a>, double <a class="el" href="external_2delaunay_2point_8h.html#adb0abda300c610b969c8be89ed30a4f6">distance</a>, <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;result)</td></tr>
<tr class="separator:gade8f7976e3d84a594d4728bf8f4c029e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54b1579073632c12c4d311be204eec3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#ga54b1579073632c12c4d311be204eec3e">Uproject_to_plane</a> (const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;r, double rot, double tilt, double psi, <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;result)</td></tr>
<tr class="separator:ga54b1579073632c12c4d311be204eec3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec185180517a9672a2ebdc0a1bfd3e77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#gaec185180517a9672a2ebdc0a1bfd3e77">Uproject_to_plane</a> (const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;r, const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;euler, <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;result)</td></tr>
<tr class="separator:gaec185180517a9672a2ebdc0a1bfd3e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9ad8d1ca1a8c56fb2a1cfe0a5990cc4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#gab9ad8d1ca1a8c56fb2a1cfe0a5990cc4">spherical_distance</a> (const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;<a class="el" href="image__find__center_8cpp.html#a1f47f51cace576c94f6c1c9483d28a8f">r1</a>, const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;<a class="el" href="image__find__center_8cpp.html#ab7a69dabaa7151dae4d7a3998167e2f3">r2</a>)</td></tr>
<tr class="separator:gab9ad8d1ca1a8c56fb2a1cfe0a5990cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3adf48a1d9643041f01f7bab097a8d44"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#ga3adf48a1d9643041f01f7bab097a8d44">point_line_distance_3D</a> (const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;p, const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;<a class="el" href="numerical__recipes_8cpp.html#af2a333b1670df64a88d3a2f22210d155">a</a>, const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;v)</td></tr>
<tr class="separator:ga3adf48a1d9643041f01f7bab097a8d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4d9e4ee82f494ed61ace73dd7a2dc81"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#gaa4d9e4ee82f494ed61ace73dd7a2dc81">point_plane_distance_3D</a> (const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;p, const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;<a class="el" href="numerical__recipes_8cpp.html#af2a333b1670df64a88d3a2f22210d155">a</a>, const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;v)</td></tr>
<tr class="separator:gaa4d9e4ee82f494ed61ace73dd7a2dc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga390c0b3d3c4ee8857d9c9e5ab36d7f30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#ga390c0b3d3c4ee8857d9c9e5ab36d7f30">least_squares_plane_fit</a> (<a class="el" href="structFitPoint.html">FitPoint</a> *IN_points, int Npoints, double &amp;plane_A, double &amp;plane_B, double &amp;plane_C)</td></tr>
<tr class="separator:ga390c0b3d3c4ee8857d9c9e5ab36d7f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga132d339f9935014a8df1c1073e6400cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#ga132d339f9935014a8df1c1073e6400cd">least_squares_plane_fit_All_Points</a> (const <a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; &amp;<a class="el" href="classImage.html">Image</a>, double &amp;plane_A, double &amp;plane_B, double &amp;plane_C)</td></tr>
<tr class="separator:ga132d339f9935014a8df1c1073e6400cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89aeed607c234539e306b114f7a33195"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#ga89aeed607c234539e306b114f7a33195">least_squares_line_fit</a> (const std::vector&lt; <a class="el" href="structfit__point2D.html">fit_point2D</a> &gt; &amp;IN_points, double &amp;line_A, double &amp;line_B)</td></tr>
<tr class="separator:ga89aeed607c234539e306b114f7a33195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaec7aca810b7ac7bdcea7a7282e6aa6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#gaaec7aca810b7ac7bdcea7a7282e6aa6c">Bspline_model_fitting</a> (const std::vector&lt; <a class="el" href="structFitPoint.html">FitPoint</a> &gt; &amp;IN_points, int SplineDegree, int l0, int lF, int m0, int mF, double h_x, double h_y, double <a class="el" href="project__crystal_8cpp.html#a94ec8a7a5cf5c289d292aef5777c4c14">x0</a>, double <a class="el" href="project__crystal_8cpp.html#a0d9521fd31b2e16413d1b78836953d53">y0</a>, <a class="el" href="classBspline__model.html">Bspline_model</a> &amp;result)</td></tr>
<tr class="separator:gaaec7aca810b7ac7bdcea7a7282e6aa6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf98f879a0edc0a55192481d00e31ae37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#gaf98f879a0edc0a55192481d00e31ae37">rectangle_enclosing</a> (const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;<a class="el" href="numerical__recipes_8cpp.html#a8eb6f9afe59b4924d42d1ea2002148e7">v0</a>, const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;vF, const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;V, <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;corner1, <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;corner2)</td></tr>
<tr class="separator:gaf98f879a0edc0a55192481d00e31ae37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3baa7ca66e02a7a51562325d28e70d47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#ga3baa7ca66e02a7a51562325d28e70d47">box_enclosing</a> (const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;<a class="el" href="numerical__recipes_8cpp.html#a8eb6f9afe59b4924d42d1ea2002148e7">v0</a>, const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;vF, const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;V, <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;corner1, <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;corner2)</td></tr>
<tr class="separator:ga3baa7ca66e02a7a51562325d28e70d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ba6558fddc767ff505f747d275ea5d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#ga4ba6558fddc767ff505f747d275ea5d4">point_inside_polygon</a> (const std::vector&lt; <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &gt; &amp;polygon, const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;point)</td></tr>
<tr class="separator:ga4ba6558fddc767ff505f747d275ea5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a2dfdbceca9c87ab5be4fbaa5cb78d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#ga3a2dfdbceca9c87ab5be4fbaa5cb78d1">def_affinity</a> (double u1x, double u1y, double u2x, double u2y, double u3x, double u3y, double t1x, double t1y, double t2x, double t2y, double t3x, double t3y, <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;A, <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;T, <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;invW)</td></tr>
<tr class="separator:ga3a2dfdbceca9c87ab5be4fbaa5cb78d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga087a4c564869f76df0f1a499737e4e50"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#ga087a4c564869f76df0f1a499737e4e50">triangle_area</a> (double x1, double y1, double x2, double y2, double x3, double y3)</td></tr>
<tr class="separator:ga087a4c564869f76df0f1a499737e4e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90c00c4b44fb178a299c96bb8587df52"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#ga90c00c4b44fb178a299c96bb8587df52">line_plane_intersection</a> (const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; normal_plane, const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; vector_line, <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;intersection_point, const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; point_line, double point_plane_at_x_y_zero=0.)</td></tr>
<tr class="separator:ga90c00c4b44fb178a299c96bb8587df52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Euler operations</h2></td></tr>
<tr class="memitem:gaf67a2d233e3fbf038d111a91197fa759"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf67a2d233e3fbf038d111a91197fa759"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Geometry.html#gaf67a2d233e3fbf038d111a91197fa759">Euler_angles2matrix</a> (T <a class="el" href="numerical__recipes_8cpp.html#af2a333b1670df64a88d3a2f22210d155">a</a>, T <a class="el" href="numerical__recipes_8cpp.html#af090b2fbbd2916bfb2e493c5162969d6">b</a>, T <a class="el" href="numerical__recipes_8cpp.html#af72286acf4184005499476fbc853146f">g</a>, <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; T &gt; &amp;A, bool homogeneous=false)</td></tr>
<tr class="separator:gaf67a2d233e3fbf038d111a91197fa759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga831e69dcc04c1853cffb899072979654"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#ga831e69dcc04c1853cffb899072979654">Euler_anglesZXZ2matrix</a> (double <a class="el" href="numerical__recipes_8cpp.html#af2a333b1670df64a88d3a2f22210d155">a</a>, double <a class="el" href="numerical__recipes_8cpp.html#af090b2fbbd2916bfb2e493c5162969d6">b</a>, double <a class="el" href="numerical__recipes_8cpp.html#af72286acf4184005499476fbc853146f">g</a>, <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;A, bool homogeneous=false)</td></tr>
<tr class="separator:ga831e69dcc04c1853cffb899072979654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0de882a451c91a7a8580614fcc57c407"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#ga0de882a451c91a7a8580614fcc57c407">Euler_distanceBetweenMatrices</a> (const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;E1, const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;E2)</td></tr>
<tr class="separator:ga0de882a451c91a7a8580614fcc57c407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d70fcf75a8e3278bee887e0ef47c3d6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9d70fcf75a8e3278bee887e0ef47c3d6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Geometry.html#ga9d70fcf75a8e3278bee887e0ef47c3d6">Euler_distanceBetweenAngleSets</a> (T rot1, T tilt1, T psi1, T rot2, T tilt2, T psi2, bool only_projdir)</td></tr>
<tr class="separator:ga9d70fcf75a8e3278bee887e0ef47c3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee274cbf4227b0a40a0192437d0ce258"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaee274cbf4227b0a40a0192437d0ce258"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Geometry.html#gaee274cbf4227b0a40a0192437d0ce258">Euler_distanceBetweenAngleSets_fast</a> (const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; T &gt; &amp;E1, T rot2, T tilt2, T psi2, bool only_projdir, <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; T &gt; &amp;E2)</td></tr>
<tr class="separator:gaee274cbf4227b0a40a0192437d0ce258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaf2fbd3996fb68c98a60633c1a8db68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#gadaf2fbd3996fb68c98a60633c1a8db68">Euler_Angles_after_compresion</a> (const double rot, double tilt, double psi, double &amp;new_rot, double &amp;new_tilt, double &amp;new_psi, <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;D)</td></tr>
<tr class="separator:gadaf2fbd3996fb68c98a60633c1a8db68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0a39b9536b704ecb1c9e44436796b2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#gac0a39b9536b704ecb1c9e44436796b2b">Euler_direction</a> (double alpha, double beta, double <a class="el" href="numerical__recipes_8cpp.html#acf097d43154f3f002dbb9692ce4c55f7">gamma</a>, <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;v)</td></tr>
<tr class="separator:gac0a39b9536b704ecb1c9e44436796b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac7ef13b5115d1ba4eee95784243cd9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#gaac7ef13b5115d1ba4eee95784243cd9c">Euler_direction2angles</a> (<a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;v, double &amp;alpha, double &amp;beta, double &amp;<a class="el" href="numerical__recipes_8cpp.html#acf097d43154f3f002dbb9692ce4c55f7">gamma</a>)</td></tr>
<tr class="separator:gaac7ef13b5115d1ba4eee95784243cd9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0889ad000c2166f766c927fc7c2f58c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#gaa0889ad000c2166f766c927fc7c2f58c">Euler_matrix2angles</a> (const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;A, double &amp;alpha, double &amp;beta, double &amp;<a class="el" href="numerical__recipes_8cpp.html#acf097d43154f3f002dbb9692ce4c55f7">gamma</a>, bool homogeneous=false)</td></tr>
<tr class="separator:gaa0889ad000c2166f766c927fc7c2f58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga927b671af65fe7edba793ca05b0c665a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#ga927b671af65fe7edba793ca05b0c665a">Euler_up_down</a> (double rot, double tilt, double psi, double &amp;newrot, double &amp;newtilt, double &amp;newpsi)</td></tr>
<tr class="separator:ga927b671af65fe7edba793ca05b0c665a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f0aa261268a10dde4daf1faab390a00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#ga4f0aa261268a10dde4daf1faab390a00">Euler_another_set</a> (double rot, double tilt, double psi, double &amp;newrot, double &amp;newtilt, double &amp;newpsi)</td></tr>
<tr class="separator:ga4f0aa261268a10dde4daf1faab390a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2025665517148ed18cd866241c8aba3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#ga2025665517148ed18cd866241c8aba3a">Euler_mirrorY</a> (double rot, double tilt, double psi, double &amp;newrot, double &amp;newtilt, double &amp;newpsi)</td></tr>
<tr class="separator:ga2025665517148ed18cd866241c8aba3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga793967c9f8c58bdd585a6bdfbe7806a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#ga793967c9f8c58bdd585a6bdfbe7806a3">Euler_mirrorX</a> (double rot, double tilt, double psi, double &amp;newrot, double &amp;newtilt, double &amp;newpsi)</td></tr>
<tr class="separator:ga793967c9f8c58bdd585a6bdfbe7806a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8e4765997f2a336493a6b7a843cd7bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#gaa8e4765997f2a336493a6b7a843cd7bd">Euler_mirrorXY</a> (double rot, double tilt, double psi, double &amp;newrot, double &amp;newtilt, double &amp;newpsi)</td></tr>
<tr class="separator:gaa8e4765997f2a336493a6b7a843cd7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a37da6506d421d52c9a102eb9732928"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#ga1a37da6506d421d52c9a102eb9732928">Euler_apply_transf</a> (const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;L, const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;R, double rot, double tilt, double psi, double &amp;newrot, double &amp;newtilt, double &amp;newpsi)</td></tr>
<tr class="separator:ga1a37da6506d421d52c9a102eb9732928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd4cd90d2c7b5471461066cb5042edb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#gadd4cd90d2c7b5471461066cb5042edb8">Euler_rotate</a> (const <a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; &amp;V, double rot, double tilt, double psi, <a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; &amp;result)</td></tr>
<tr class="separator:gadd4cd90d2c7b5471461066cb5042edb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae58ee12942ad4fe5a7d07ab7b988a827"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#gae58ee12942ad4fe5a7d07ab7b988a827">Euler_rotate</a> (const <a class="el" href="classMultidimArrayGeneric.html">MultidimArrayGeneric</a> &amp;V, double rot, double tilt, double psi, <a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; &amp;result)</td></tr>
<tr class="separator:gae58ee12942ad4fe5a7d07ab7b988a827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae41a5015cbfd6ab97119d08e572cd23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#gaae41a5015cbfd6ab97119d08e572cd23">computeCircleAroundE</a> (const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;E, double angCircle, double angStep, std::vector&lt; double &gt; &amp;outputEulerAngles)</td></tr>
<tr class="separator:gaae41a5015cbfd6ab97119d08e572cd23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9a01090711842bea6f6fe759ca71ceb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#gac9a01090711842bea6f6fe759ca71ceb">EULER_CLIPPING</a>(rot,  tilt,  psi)</td></tr>
<tr class="separator:gac9a01090711842bea6f6fe759ca71ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5eed0e298c6feb8b860a764f5eeab84d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#ga5eed0e298c6feb8b860a764f5eeab84d">EULER_CLIPPING_RAD</a>(rot,  tilt,  psi)</td></tr>
<tr class="separator:ga5eed0e298c6feb8b860a764f5eeab84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Intersections</h2></td></tr>
<tr class="memitem:ga64b58172fd2a45ebeae5e7ce3216ec1c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#ga64b58172fd2a45ebeae5e7ce3216ec1c">intersection_unit_sphere</a> (const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;<a class="el" href="numerical__recipes_8cpp.html#a6277e2a7446059985dc9bcf0a4ac1a8f">u</a>, const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;r)</td></tr>
<tr class="separator:ga64b58172fd2a45ebeae5e7ce3216ec1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad110429984082334e49641f5bca50c02"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#gad110429984082334e49641f5bca50c02">intersection_unit_cylinder</a> (const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;<a class="el" href="numerical__recipes_8cpp.html#a6277e2a7446059985dc9bcf0a4ac1a8f">u</a>, const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;r)</td></tr>
<tr class="separator:gad110429984082334e49641f5bca50c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc3d2cc2704dd94b49fb8c2c0fc5a977"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry.html#gabc3d2cc2704dd94b49fb8c2c0fc5a977">intersection_unit_cube</a> (const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;<a class="el" href="numerical__recipes_8cpp.html#a6277e2a7446059985dc9bcf0a4ac1a8f">u</a>, const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;r)</td></tr>
<tr class="separator:gabc3d2cc2704dd94b49fb8c2c0fc5a977"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gac9a01090711842bea6f6fe759ca71ceb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EULER_CLIPPING</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rot, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tilt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">psi&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">rot = <a class="code" href="group__Macros.html#ga25935c2309abe02cff60809c4d7d9b9e">realWRAP</a>(rot, 0, 360); \</div><div class="line">    tilt = <a class="code" href="group__Macros.html#ga25935c2309abe02cff60809c4d7d9b9e">realWRAP</a>(tilt, 0, 360); <a class="code" href="namespacealglib.html#a0759579762ef75075769325153538c5b">\</a></div><div class="line"><a class="code" href="namespacealglib.html#a0759579762ef75075769325153538c5b">    psi</a> = <a class="code" href="group__Macros.html#ga25935c2309abe02cff60809c4d7d9b9e">realWRAP</a>(<a class="code" href="namespacealglib.html#a0759579762ef75075769325153538c5b">psi</a>, 0, 360);</div><div class="ttc" id="namespacealglib_html_a0759579762ef75075769325153538c5b"><div class="ttname"><a href="namespacealglib.html#a0759579762ef75075769325153538c5b">alglib::psi</a></div><div class="ttdeci">double psi(const double x)</div><div class="ttdef"><b>Definition:</b> specialfunctions.cpp:2492</div></div>
<div class="ttc" id="group__Macros_html_ga25935c2309abe02cff60809c4d7d9b9e"><div class="ttname"><a href="group__Macros.html#ga25935c2309abe02cff60809c4d7d9b9e">realWRAP</a></div><div class="ttdeci">#define realWRAP(x, x0, xF)</div><div class="ttdef"><b>Definition:</b> xmipp_macros.h:304</div></div>
</div><!-- fragment --><p>Getting the <a class="el" href="classEuler.html">Euler</a> angles to a range (0-360). No direction equivalence is applied, ie, there is no correction of the direction of projection making use that a view from the top is the same as a view from the bottom but reversed ... Just a wrapping of the angles is done until the angles fall in the specified ranges. The angles given must be variables and they are modified with the new values. </p>

</div>
</div>
<a class="anchor" id="ga5eed0e298c6feb8b860a764f5eeab84d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EULER_CLIPPING_RAD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rot, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tilt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">psi&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">rot = <a class="code" href="group__Macros.html#ga25935c2309abe02cff60809c4d7d9b9e">realWRAP</a>(rot, 0, 2.0*<a class="code" href="tools_8h.html#a598a3330b3c21701223ee0ca14316eca">PI</a>); \</div><div class="line">    tilt = <a class="code" href="group__Macros.html#ga25935c2309abe02cff60809c4d7d9b9e">realWRAP</a>(tilt, 0, 2.0*<a class="code" href="tools_8h.html#a598a3330b3c21701223ee0ca14316eca">PI</a>); <a class="code" href="namespacealglib.html#a0759579762ef75075769325153538c5b">\</a></div><div class="line"><a class="code" href="namespacealglib.html#a0759579762ef75075769325153538c5b">    psi</a> = <a class="code" href="group__Macros.html#ga25935c2309abe02cff60809c4d7d9b9e">realWRAP</a>(<a class="code" href="namespacealglib.html#a0759579762ef75075769325153538c5b">psi</a>, 0, 2.0*<a class="code" href="tools_8h.html#a598a3330b3c21701223ee0ca14316eca">PI</a>);</div><div class="ttc" id="namespacealglib_html_a0759579762ef75075769325153538c5b"><div class="ttname"><a href="namespacealglib.html#a0759579762ef75075769325153538c5b">alglib::psi</a></div><div class="ttdeci">double psi(const double x)</div><div class="ttdef"><b>Definition:</b> specialfunctions.cpp:2492</div></div>
<div class="ttc" id="group__Macros_html_ga25935c2309abe02cff60809c4d7d9b9e"><div class="ttname"><a href="group__Macros.html#ga25935c2309abe02cff60809c4d7d9b9e">realWRAP</a></div><div class="ttdeci">#define realWRAP(x, x0, xF)</div><div class="ttdef"><b>Definition:</b> xmipp_macros.h:304</div></div>
<div class="ttc" id="tools_8h_html_a598a3330b3c21701223ee0ca14316eca"><div class="ttname"><a href="tools_8h.html#a598a3330b3c21701223ee0ca14316eca">PI</a></div><div class="ttdeci">#define PI</div><div class="ttdef"><b>Definition:</b> tools.h:43</div></div>
</div><!-- fragment --><p>Getting the <a class="el" href="classEuler.html">Euler</a> angles to a range (0-2*PI).</p>
<p>The same as before but the angles are expressed in radians. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga3baa7ca66e02a7a51562325d28e70d47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void box_enclosing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>corner1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>corner2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Box which encloses a deformed box</p>
<p>Given a box characterized by the top-left corner (most negative) and the right-bottom (most positive) corner, and given a matrix after which the box is deformed. Which is the minimum box which encloses the preceding one? This function is useful for stablishing for loops which will cover for sure the deformed box. All vectors are supposed to be 3x1 and the deformation matrix is 3x3. The corner (x0,y0,z0) goes to V*(x0,y0,z0)' and (xF,yF,zF) to V*(xf,yF,zF)'. After that you can make a loop from corner1 to corner2.</p>
<p>The v0 and vF vectors can be reused as outputs. </p>

</div>
</div>
<a class="anchor" id="gaaec7aca810b7ac7bdcea7a7282e6aa6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Bspline_model_fitting </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structFitPoint.html">FitPoint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>IN_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>SplineDegree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBspline__model.html">Bspline_model</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Least-squares fit of a B-spline 2D model</p>
<p>For fitting a set of values that are distributed between (x0,y0) and (xF,yF) with a cubic Bspline centered on each corner, the right call is</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Bspline_model model;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Bspline_model_fitting(list_of_points, 3, -1, 2, -1, 2, xF-x0, yF-y0, x0,</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    y0, model);</div></div><!-- fragment --><p>Once the model is returned you can evaluate it at any point simply by</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;model.evaluate(x,y);</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaae41a5015cbfd6ab97119d08e572cd23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void computeCircleAroundE </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angCircle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angStep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputEulerAngles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute circle around <a class="el" href="classEuler.html">Euler</a> matrix</p>
<p>Given an input <a class="el" href="classEuler.html">Euler</a> matrix, this function returns a set of <a class="el" href="classEuler.html">Euler</a> angles such that they sample a circle around the original projection direction (a sample every angStep). The projection directions in the circle are separated by angCircle.</p>
<p>The output is in outputEulerAngles whose structure is (newrot1,newtilt1,newpsi1,newrot2,newtilt2,newpsi2,...) </p>

</div>
</div>
<a class="anchor" id="ga3a2dfdbceca9c87ab5be4fbaa5cb78d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void def_affinity </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>u1x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>u1y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>u2x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>u2y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>u3x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>u3y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t1x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t1y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t2x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t2y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t3x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t3y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>invW</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Affine transformation </p>

</div>
</div>
<a class="anchor" id="gaf67a2d233e3fbf038d111a91197fa759"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Euler_angles2matrix </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>homogeneous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classEuler.html">Euler</a> angles &ndash;&gt; <a class="el" href="classEuler.html">Euler</a> matrix.</p>
<p>This function returns the transformation matrix associated to the 3 given <a class="el" href="classEuler.html">Euler</a> angles (in degrees).</p>
<p>As an implementation note you might like to know that this function calls always to <a class="el" href="classMatrix2D.html#aeedb221b3c316a93de2826d56302bf98">Matrix2D::resize</a></p>
<p>See <a href="http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/EulerAngles">http://xmipp.cnb.csic.es/twiki/bin/view/Xmipp/EulerAngles</a> for a description of the <a class="el" href="classEuler.html">Euler</a> angles. </p>

</div>
</div>
<a class="anchor" id="gadaf2fbd3996fb68c98a60633c1a8db68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Euler_Angles_after_compresion </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>psi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>new_rot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>new_tilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>new_psi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Angles after compresion</p>
<p>Let be two volumes f and g related by g(x,y,z) = f(D(x,y,z)) (where D is a lineal transformation) then the projection direction parallel to the vector w in f is going to be related with the projection direction parallel to the vector w_prime in g. Given the w <a class="el" href="classEuler.html">Euler</a> angles this routine provide the w_prime angles </p>

</div>
</div>
<a class="anchor" id="ga831e69dcc04c1853cffb899072979654"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Euler_anglesZXZ2matrix </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>homogeneous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classEuler.html">Euler</a> angles &ndash;&gt; <a class="el" href="classEuler.html">Euler</a> matrix.</p>
<p>This function returns the transformation matrix associated to the 3 given <a class="el" href="classEuler.html">Euler</a> angles (in degrees). </p>

</div>
</div>
<a class="anchor" id="ga4f0aa261268a10dde4daf1faab390a00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Euler_another_set </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>psi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>newrot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>newtilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>newpsi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same view but differently expressed</p>
<p>As you know a projection view from a point can be expressed with different sets of <a class="el" href="classEuler.html">Euler</a> angles. This function gives you another expression of the <a class="el" href="classEuler.html">Euler</a> angles for this point of view. Exactly the operation performed is:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;newrot = rot + 180;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;newtilt = -tilt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;newpsi = -180 + psi;</div></div><!-- fragment --><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Euler_another_set(rot, tilt, psi, newrot, newtilt, newpsi);</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga1a37da6506d421d52c9a102eb9732928"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Euler_apply_transf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>psi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>newrot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>newtilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>newpsi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply a geometrical transformation</p>
<p>The idea behind this function is the following. 3 <a class="el" href="classEuler.html">Euler</a> angles define a point of view for a projection, but also a coordinate system. You might apply a geometrical transformation to this system, and then compute back what the <a class="el" href="classEuler.html">Euler</a> angles for the new system are. This could be used to "mirror" points of view, rotate them and all the stuff. The transformation matrix must be 3x3 but it must transform R3 vectors into R3 vectors (that is a normal 3D transformation matrix when vector coordinates are not homogeneous) and it will be applied in the sense:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;New Euler matrix = L * Old Euler matrix * R</div></div><!-- fragment --><p>where you know that the <a class="el" href="classEuler.html">Euler</a> matrix rows represent the different system axes. See Euler_angles2matrix for more information about the <a class="el" href="classEuler.html">Euler</a> coordinate system.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Matrix2D&lt; double &gt; R60 = rotation3DMatrix(60, &#39;Z&#39;);</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;R60.resize(3, 3); // Get rid of homogeneous part</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;Matrix2D&lt; double &gt; I(3, 3);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;I.initIdentity();</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;Euler_apply_transf(I, R60, rot, tilt, psi, newrot, newtilt, newpsi);</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gac0a39b9536b704ecb1c9e44436796b2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Euler_direction </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classEuler.html">Euler</a> direction</p>
<p>This function returns a vector parallel to the projection direction. Resizes v if needed </p>

</div>
</div>
<a class="anchor" id="gaac7ef13b5115d1ba4eee95784243cd9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Euler_direction2angles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>gamma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classEuler.html">Euler</a> direction2angles</p>
<p>This function returns the 3 <a class="el" href="classEuler.html">Euler</a> angles associated to the direction given by the vector v. The 3rd <a class="el" href="classEuler.html">Euler</a> angle is set always to 0 </p>

</div>
</div>
<a class="anchor" id="ga9d70fcf75a8e3278bee887e0ef47c3d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Euler_distanceBetweenAngleSets </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rot1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>tilt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>psi1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rot2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>tilt2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>psi2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>only_projdir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Average distance between two angle sets. If the only_projdir is set, then only the projection direction is considered. </p>

</div>
</div>
<a class="anchor" id="gaee274cbf4227b0a40a0192437d0ce258"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Euler_distanceBetweenAngleSets_fast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>E1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>rot2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>tilt2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>psi2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>only_projdir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>E2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Average distance between two angle sets. E1 must contain the <a class="el" href="classEuler.html">Euler</a> matrix corresponding to set1, E2 is used as an auxiliary variable for storing the second <a class="el" href="classEuler.html">Euler</a> matrix. </p>

</div>
</div>
<a class="anchor" id="ga0de882a451c91a7a8580614fcc57c407"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Euler_distanceBetweenMatrices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>E1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>E2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Distance between two <a class="el" href="classEuler.html">Euler</a> matrices.</p>
<p>The distance is defined as 1/3*(X1.X2 + Y1.Y2 + Z1.Z2) </p>

</div>
</div>
<a class="anchor" id="gaa0889ad000c2166f766c927fc7c2f58c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Euler_matrix2angles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>homogeneous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>"Euler" matrix &ndash;&gt; angles</p>
<p>This function compute a set of <a class="el" href="classEuler.html">Euler</a> angles which result in an "Euler" matrix as the one given. See <a class="el" href="group__Geometry.html#gaf67a2d233e3fbf038d111a91197fa759">Euler_angles2matrix</a> to know more about how this matrix is computed and what each row means. The result angles are in degrees. Alpha, beta and gamma are respectively the first, second and third rotation angles. If the input matrix is not 3x3 then an exception is thrown, the function doesn't check that the <a class="el" href="classEuler.html">Euler</a> matrix is truly representing a coordinate system.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Euler_matrix2angles(Euler, alpha, beta, gamma);</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga793967c9f8c58bdd585a6bdfbe7806a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Euler_mirrorX </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>psi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>newrot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>newtilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>newpsi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mirror over X axis</p>
<p>Given a set of <a class="el" href="classEuler.html">Euler</a> angles this function returns a new set which define a mirrored (over X axis) version of the former projection.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;-----&gt; X               Y</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;|                       ^</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;|                       |</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;|               ======&gt; |</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;v                       |</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;Y                        -----&gt; X</div></div><!-- fragment --><p>The operation performed is</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;newrot = rot;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;newtilt = tilt + 180;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;newpsi = 180 - psi;</div></div><!-- fragment --><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Euler_mirrorX(rot, tilt, psi, newrot, newtilt, newpsi);</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaa8e4765997f2a336493a6b7a843cd7bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Euler_mirrorXY </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>psi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>newrot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>newtilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>newpsi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mirror over X and Y axes</p>
<p>Given a set of <a class="el" href="classEuler.html">Euler</a> angles this function returns a new set which define a mirrored (over X and Y axes at the same time) version of the former projection.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;-----&gt; X                       Y</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;|                               ^</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;|                               |</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;|               ======&gt;         |</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;v                               |</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;Y                        X&lt;-----</div></div><!-- fragment --><p>The operation performed is</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;newrot = rot;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;newtilt = tilt;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;newpsi = 180 + psi;</div></div><!-- fragment --><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Euler_mirrorX(rot, tilt, psi, newrot, newtilt, newpsi);</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga2025665517148ed18cd866241c8aba3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Euler_mirrorY </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>psi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>newrot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>newtilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>newpsi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mirror over Y axis</p>
<p>Given a set of <a class="el" href="classEuler.html">Euler</a> angles this function returns a new set which define a mirrored (over Y axis) version of the former projection.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;-----&gt; X               X&lt;------</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;|                              |</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;|                              |</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;|               ======&gt;        |</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;v                              v</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;Y                             Y</div></div><!-- fragment --><p>The operation performed is</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;newrot = rot;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;newtilt = tilt + 180;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;newpsi = -psi;</div></div><!-- fragment --><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Euler_mirrorY(rot, tilt, psi, newrot, newtilt, newpsi);</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gadd4cd90d2c7b5471461066cb5042edb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Euler_rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>psi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rotate a volume after 3 <a class="el" href="classEuler.html">Euler</a> angles</p>
<p>Input and output volumes cannot be the same one. </p>

</div>
</div>
<a class="anchor" id="gae58ee12942ad4fe5a7d07ab7b988a827"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Euler_rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMultidimArrayGeneric.html">MultidimArrayGeneric</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>psi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rotate a volume after 3 <a class="el" href="classEuler.html">Euler</a> angles</p>
<p>Input and output volumes cannot be the same one. </p>

</div>
</div>
<a class="anchor" id="ga927b671af65fe7edba793ca05b0c665a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Euler_up_down </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>psi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>newrot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>newtilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>newpsi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Up-Down projection equivalence</p>
<p>As you know a projection view from a point has got its homologous from its diametrized point in the projection sphere. This function takes a projection defined by its 3 <a class="el" href="classEuler.html">Euler</a> angles and computes an equivalent set of <a class="el" href="classEuler.html">Euler</a> angles from which the view is exactly the same but in the other part of the sphere (if the projection is taken from the bottom then the new projection from the top, and viceversa). The defined projections are exactly the same except for a flip over X axis, ie, an up-down inversion. Exactly the correction performed is:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;newrot = rot;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;newtilt = tilt + 180;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;newpsi = -(180 + psi);</div></div><!-- fragment --><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Euler_up_down(rot, tilt, psi, newrot, newtilt, newpsi);</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gabc3d2cc2704dd94b49fb8c2c0fc5a977"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double intersection_unit_cube </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Intersection of a ray with a unit cube</p>
<p>The cube is centered at (0,0,0) and has got unit size length in all directions, i.e., the cube goes from (-0.5, -0.5, -0.5) to (0.5, 0.5, 0.5). The ray is defined by its direction (u) and a passing point (r). See <a class="el" href="classCube.html">Cube</a> to know how you can intersect any ray with any cube. </p>

</div>
</div>
<a class="anchor" id="gad110429984082334e49641f5bca50c02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double intersection_unit_cylinder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Intersection of a ray with a unit cylinder</p>
<p>The cylinder is centered at (0,0,0), has got unit radius on the plane XY, and in Z goes from -h/2 to +h/2. The ray is defined by its direction (u) and a passing point (r). If the ray belongs to the lateral circular wall of the cylinder the length returned is h (h is computed as 1/ZZ(u), this is so because it is supposed that this intersection is computed after a coordinate transformation process from any cylinder to a unit one).</p>
<p>See <a class="el" href="classCylinder.html">Cylinder</a> to know how you can intersect any ray with any cylinder. </p>

</div>
</div>
<a class="anchor" id="ga64b58172fd2a45ebeae5e7ce3216ec1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double intersection_unit_sphere </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Intersection of a ray with a unit sphere</p>
<p>The sphere is centered at (0,0,0) and has got unit radius. The ray is defined by its direction (u) and a passing point (r). The function returns the length of the intersection. If the ray is tangent to the sphere the length is 0. See <a class="el" href="classEllipsoid.html">Ellipsoid</a> to know how you can intersect any ray with any ellipsoid/sphere. </p>

</div>
</div>
<a class="anchor" id="ga89aeed607c234539e306b114f7a33195"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void least_squares_line_fit </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structfit__point2D.html">fit_point2D</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>IN_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>line_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>line_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Least-squares-fit a line to an arbitrary number of (x,y) points</p>
<p>Plane described as Ax + B = y</p>
<p>Points are defined using the struct</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;struct fit_point2D</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    double x;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    double y;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    double w;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;};</div></div><!-- fragment --><p>where w is a weighting factor. Set it to 1 if you do not want to use it </p>

</div>
</div>
<a class="anchor" id="ga390c0b3d3c4ee8857d9c9e5ab36d7f30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void least_squares_plane_fit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFitPoint.html">FitPoint</a> *&#160;</td>
          <td class="paramname"><em>IN_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Npoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>plane_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>plane_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>plane_C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Least-squares-fit a plane to an arbitrary number of (x,y,z) points</p>
<p>Plane described as Ax + By + C = z</p>
<p>Points are defined using the struct</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;struct fit_point</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    double x;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    double y;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    double z;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    double w;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;};</div></div><!-- fragment --><p>where w is a weighting factor. Set it to 1 if you do not want to use it </p>

</div>
</div>
<a class="anchor" id="ga132d339f9935014a8df1c1073e6400cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void least_squares_plane_fit_All_Points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMultidimArray.html">MultidimArray</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>plane_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>plane_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>plane_C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Least-squares-fit a plane to an image</p>
<p>Performs the same computation as least_squares_plane_fit but using a complete image instead of only a set of points. </p>

</div>
</div>
<a class="anchor" id="ga90c00c4b44fb178a299c96bb8587df52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int line_plane_intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>normal_plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>vector_line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>intersection_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>point_line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>point_plane_at_x_y_zero</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Line Plane Intersection</p>
<p>Let ax+by+cz+D=0 be the equation of your plane (if your plane is defined by a normal vector N + one point M, then (a,b,c) are the coordinates of the normal N, and d is calculated by using the coordinates of M in the above equation).</p>
<p>Let your line be defined by one point P(d,e,f) and a vector V(u,v,w), the points on your line are those which verify</p>
<p>x = d + lu y = e + lv z = f + lw</p>
<p>where l takes all real values.</p>
<p>for this point to be on the plane, you have to have</p>
<p>ax + by + cz + D = 0, so,</p>
<p>a(d + lu) + b(e + lv) + c(f + lw) + D = 0</p>
<p>that is</p>
<p>l(au + bv + cw) = -(ad + be + cf + D)</p>
<p>note that, if au + bv + cw = 0, then your line is either in the plane, or parallel to it... otherwise you get the value of l, and the intersection has coordinates:</p>
<p>x = d + lu y = e + lv z = f + lw</p>
<p>where</p>
<p>l = -(ad + be + cf + D) / (au + bv + cw)</p>
<p>a = <a class="el" href="group__Vectors.html#ga7dce99001bf2a5ec705503346b6fec85">XX(normal_plane)</a>; b = <a class="el" href="group__Vectors.html#ga8b0ce0c5282ce1bae56cc1f9ed4b6a5f">YY(normal_plane)</a>; c = <a class="el" href="group__Vectors.html#gab88d1e959fb58c03aa1f04f1e4a7d452">ZZ(normal_plane)</a>; D = intersection_point;</p>
<p>d = <a class="el" href="group__Vectors.html#ga7dce99001bf2a5ec705503346b6fec85">XX(point_line)</a> e = <a class="el" href="group__Vectors.html#ga8b0ce0c5282ce1bae56cc1f9ed4b6a5f">YY(point_line)</a> f = <a class="el" href="group__Vectors.html#gab88d1e959fb58c03aa1f04f1e4a7d452">ZZ(point_line)</a></p>
<p>u = <a class="el" href="group__Vectors.html#ga7dce99001bf2a5ec705503346b6fec85">XX(vector_line)</a>; v = <a class="el" href="group__Vectors.html#ga8b0ce0c5282ce1bae56cc1f9ed4b6a5f">YY(vector_line)</a>; w = <a class="el" href="group__Vectors.html#gab88d1e959fb58c03aa1f04f1e4a7d452">ZZ(vector_line)</a>;</p>
<p><a class="el" href="group__Vectors.html#ga7dce99001bf2a5ec705503346b6fec85">XX(intersection_point)</a> = x; <a class="el" href="group__Vectors.html#ga8b0ce0c5282ce1bae56cc1f9ed4b6a5f">YY(intersection_point)</a> = y; <a class="el" href="group__Vectors.html#gab88d1e959fb58c03aa1f04f1e4a7d452">ZZ(intersection_point)</a> = z;</p>
<p>return 0 if successful return -1 if line parallel to plane return +1 if line in the plane </p>

</div>
</div>
<a class="anchor" id="ga4ba6558fddc767ff505f747d275ea5d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool point_inside_polygon </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="structPoint.html">Point</a> inside polygon</p>
<p>Given a polygon described by a list of points (the last one and the first one ust be the same), determine whether another point is inside the polygon or not. </p>

</div>
</div>
<a class="anchor" id="ga3adf48a1d9643041f01f7bab097a8d44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double point_line_distance_3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="structPoint.html">Point</a> to line distance in 3D</p>
<p>Let a line in 3-D be specified by the point a and the vector v, this fuction returns the minimum distance of this line to the point p. </p>

</div>
</div>
<a class="anchor" id="gaa4d9e4ee82f494ed61ace73dd7a2dc81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double point_plane_distance_3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="structPoint.html">Point</a> to plane distance in 3D</p>
<p>Let a plane in 3-D be specified by the point a and the perpendicular vector v, this fuction returns the minimum distance of this plane to the point p. </p>

</div>
</div>
<a class="anchor" id="gaf98f879a0edc0a55192481d00e31ae37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rectangle_enclosing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>corner1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>corner2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classRectangle.html">Rectangle</a> which encloses a deformed rectangle</p>
<p>Given a rectangle characterized by the top-left corner and the right-bottom corner, and given a matrix after which the rectangle is deformed. Which is the minimum rectangle which encloses the preceding one? This function is useful for stablishing for loops which will cover for sure the deformed rectangle. All vectors are supposed to be 2x1 and the deformation matrix is 2x2. The corner (x0,y0) goes to V*(x0,y0)' and (xF,yF) to V*(xf,yF)'. After that you can make a loop from corner1 to corner2.</p>
<p>The v0 and vF vectors can be reused as outputs. </p>

</div>
</div>
<a class="anchor" id="gab9ad8d1ca1a8c56fb2a1cfe0a5990cc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double spherical_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Spherical distance</p>
<p>This function returns the distance over a sphere, not the straight line but the line which goes from one point to the other going over the surface of a sphere, supposing that both points lie on the same sphere. </p>

</div>
</div>
<a class="anchor" id="ga087a4c564869f76df0f1a499737e4e50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double triangle_area </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Area of a triangle Given the coordinates of three points this function calculates the area of the triangle </p>

</div>
</div>
<a class="anchor" id="gade8f7976e3d84a594d4728bf8f4c029e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Uproject_to_plane </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Project a point to a plane (direction vector, distance)</p>
<p>Given the coordinates for a vector in R3, and a plane (defined by its direction vector and the minimum distance from the plane to the coordinate system origin). This function computes the perpendicular projection from the vector to the plane. This function has tried to be optimized in speed as it is used in core routines within huge loops, this is why the result is given as an argument, and why no check about the dimensionality of the vectors is performed. The routine performs faster if the result vector is already in R3.</p>
<p>The following example projects the point P=(1,1,1) to the XY-plane storing the result in Pp (belonging to R3), the result is obviously Pp=(1,1,0).</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Matrix1D&lt; double &gt; Z = vectorR3(0, 0, 1), P = vector_R3(1, 1, 1), Pp(3);</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Uproject_to_plane(P,Z,0,Pp);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;std::cout &lt;&lt; &quot;After projecting: Pp=&quot; &lt;&lt; Pp.transpose() &lt;&lt; std::endl;</div></div><!-- fragment --><p>The starting U in the function name stands for the fact that the plane and the point are in the same reference system (called by default Universal).</p>
<p>The result and point vectors can be the same one. </p>

</div>
</div>
<a class="anchor" id="ga54b1579073632c12c4d311be204eec3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Uproject_to_plane </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>psi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Project a vector to a plane (<a class="el" href="classEuler.html">Euler</a> angles)</p>
<p>These planes are restricted to have 0 distance to the universal coordinate system. In this special case, a plane can be defined by 3 <a class="el" href="classEuler.html">Euler</a> angles (this is specially suited for projections, where the projection plane is defined by its 3 <a class="el" href="classEuler.html">Euler</a> angles). Then, the coordinate system associated to the 3 <a class="el" href="classEuler.html">Euler</a> angles (let's call its vectors X',Y',Z') defines a projection plane where Z' is the direction vector, and X'Y' are in-plane vectors. Actually, X' coincides with the X vector in the <a class="el" href="classMatrix2D.html">Matrix2D</a> definition and Y' with the Y vector.</p>
<p>The resulting vector is in R3, and the function has been optimized for speed, so the result is passed as a parameter. This function is based in the one which projects a point given the <a class="el" href="classEuler.html">Euler</a> matrix of the projection plane. If you are to project several points to the same plane, you should better use the project to plane function where you give the <a class="el" href="classEuler.html">Euler</a> matrix.</p>
<p>The following example projects the point P=(1,1,1) to the XY-plane storing the result in Pp (belonging to R3), the result is obviously Pp=(1,1,0).</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Matrix1D&lt; double &gt; P = vectorR3(1, 1, 1), Pp(3);</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Uproject_to_plane(P, 0, 0, 0, Pp);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;std::cout &lt;&lt; &quot;After projecting: Pp=&quot; &lt;&lt; Pp.transpose() &lt;&lt; std::endl;</div></div><!-- fragment --><p>The starting U in the function name stands for the fact that the plane, and the point are in the same reference system (called by default Universal).</p>
<p>The result and point vectors can be the same one. </p>

</div>
</div>
<a class="anchor" id="gaec185180517a9672a2ebdc0a1bfd3e77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Uproject_to_plane </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrix2D.html">Matrix2D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>euler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrix1D.html">Matrix1D</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Project a vector to a plane (<a class="el" href="classEuler.html">Euler</a> matrix)</p>
<p>These planes are restricted to have 0 distance to the universal coordinate system. In this special case, a plane can be defined by 3 <a class="el" href="classEuler.html">Euler</a> angles (this is specially suited for projections, where the projection plane is defined by its 3 <a class="el" href="classEuler.html">Euler</a> angles). Then, the coordinate system associated to the 3 <a class="el" href="classEuler.html">Euler</a> angles (let's call its vectors X',Y',Z') defines a projection plane where Z' is the direction vector, and X'Y' are in-plane vectors. Actually, X' coincides with the X vector in the <a class="el" href="classMatrix2D.html">Matrix2D</a> definition and Y' with the Y vector.</p>
<p>The resulting vector is in R3, and the function has been optimized for speed, if the result vector is already 3 dimensional when entering the function, no resize is performed; and the result is passed as a parameter. If you are to project several points to the same plane, you should better use the project to plane function where you give the <a class="el" href="classEuler.html">Euler</a> matrix.</p>
<p>The following example projects the point P=(1,1,1) to the XY-plane storing the result in Pp (belonging to R3), the result is obviously Pp=(1,1,0).</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Matrix1D&lt; double &gt; P = vectorR3(1, 1, 1), Pp(3);</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Matrix2D&lt; double &gt; euler;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;Euler_angles2matrix(0, 0, 0, euler);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;Uproject_to_plane(P, euler, Pp);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;std::cout &lt;&lt; &quot;After projecting: Pp=&quot; &lt;&lt; Pp.transpose() &lt;&lt; std::endl;</div></div><!-- fragment --><p>The starting U in the function name stands for the fact that the plane, and the point are in the same reference system (called by default Universal).</p>
<p>The result and point vectors can be the same one. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
